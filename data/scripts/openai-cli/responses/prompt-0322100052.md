# Dry-run Prompt
## Metadata
### Token Summary
```
Instruction Tokens:                   30,921
Simulated User Prompt Tokens:         13,107
Simulated Assistent Response Tokens:   9,244
New User Prompt Tokens:               12,439
Total Tokens:                         90,711
Model Max Tokens:                    100,000

```
## Instructions
Convert a given TypeScript code file containing an AWS CDK Construct to a TerraConstruct (using CDKTF), following specified guidance and examples.
Ensure the output is a valid source code file that can be directly written to disk.
Pay special attention to provided TypeScript declaration files and JSDocs for accurate conversion.

## Conversion Guidelines

- Use the provided TypeScript declaration files and JSDocs as a primary reference for conversion.
- Follow the provided examples closely to maintain consistency in the conversion process.
- Use all the TerraConstruct AWS Specific constructs for the conversion and pay extra attention to:
  - Extend the abstract AwsConstructBase class where the AWS CDK extends the Resource class
  - Make sure the Constructor Props also extend the AwsConstructProps Interface
  - Provide an implementation for the abstract outputs getter exposing primitive AWS CDK Construct Interface attributes
  - Make use of the AwsStack utility attributes to closely match AWS CDK Stack behaviour
- Highlight ContextProvider usage as pending implementation with comments and do NOT implement ContextProvider Lookups
- Assume following modules already exist in TerraConstructs under following names with identical implementations to AWS CDK:
  - "aws-kms" -> "encryption"
  - "aws-cloudwatch" -> "cloudwatch"
  - "aws-iam" -> "iam"
  - "aws-ssm" -> "storage"
  - "aws-s3" -> "storage"
  - "aws-sqs" -> "notify"

## Reference Documents

**TerraConstructs Core Type Declarations**
```typescript
../..//construct-base
import { TerraformResource, TerraformElement, TerraformMetaArguments, IAspect } from "cdktf";
import { Construct, IConstruct } from "constructs";
export interface TerraConstructProps extends TerraformMetaArguments {
    /**
     * The friendly name for TerraConstruct resources
     *
     * @default - `environmentName-id`
     */
    readonly friendlyName?: string;
    /**
     * Whether to register Terraform outputs for this TerraConstruct
     *
     * @default false
     */
    readonly registerOutputs?: boolean;
    /**
     * Optional override for the outputs name
     *
     * @default id
     */
    readonly outputName?: string;
}
export interface ITerraConstruct extends IConstruct {
    /**
     * Environment Name passed in from the CLI
     */
    readonly environmentName: string;
    readonly gridUUID: string;
    readonly outputs: Record<string, any>;
}
export type TaggableConstruct = TerraformResource & {
    tags?: {
        [key: string]: string;
    };
    tagsInput?: {
        [key: string]: string;
    };
};
export declare function isTaggableTerraformResource(x: IConstruct): x is TaggableConstruct;
export declare class GridTags implements IAspect {
    private tagsToAdd;
    constructor(tagsToAdd: Record<string, string>);
    visit(node: IConstruct): void;
}
/**
 * Base class for all TerraConstructs
 *
 * Allows a TerraConstruct to lazily register its outputs with its parent Stack
 */
export declare abstract class TerraConstructBase extends TerraformElement implements ITerraConstruct {
    private readonly constructId;
    /**
     * Returns true if the construct was created by CDKTF, and false otherwise
     */
    static isOwnedResource(construct: IConstruct): boolean;
    /**
     * The name under which the outputs are registered in the parent Scope
     */
    readonly outputName: string;
    /**
     * TerraConstruct friendly name
     */
    readonly friendlyName: string;
    /**
     * TerraConstruct unique grid identifier
     */
    get gridUUID(): string;
    /**
     * Environment Name passed in from the CLI
     */
    get environmentName(): string;
    /**
     * Outputs to register with the parent Scope or undefined if there are no outputs
     */
    abstract get outputs(): Record<string, any>;
    constructor(scope: Construct, constructId: string, props?: TerraConstructProps);
    get fqn(): string;
}


../..//duration
/**
 * Represents a length of time.
 *
 * The amount can be specified either as a literal value (e.g: `10`) which
 * cannot be negative, or as an unresolved number token.
 *
 * When the amount is passed as a token, unit conversion is not possible.
 */
export declare class Duration {
    /**
     * Create a Duration representing an amount of milliseconds
     *
     * @param amount the amount of Milliseconds the `Duration` will represent.
     * @returns a new `Duration` representing `amount` ms.
     */
    static millis(amount: number): Duration;
    /**
     * Create a Duration representing an amount of seconds
     *
     * @param amount the amount of Seconds the `Duration` will represent.
     * @returns a new `Duration` representing `amount` Seconds.
     */
    static seconds(amount: number): Duration;
    /**
     * Create a Duration representing an amount of minutes
     *
     * @param amount the amount of Minutes the `Duration` will represent.
     * @returns a new `Duration` representing `amount` Minutes.
     */
    static minutes(amount: number): Duration;
    /**
     * Create a Duration representing an amount of hours
     *
     * @param amount the amount of Hours the `Duration` will represent.
     * @returns a new `Duration` representing `amount` Hours.
     */
    static hours(amount: number): Duration;
    /**
     * Create a Duration representing an amount of days
     *
     * @param amount the amount of Days the `Duration` will represent.
     * @returns a new `Duration` representing `amount` Days.
     */
    static days(amount: number): Duration;
    /**
     * Parse a period formatted according to the ISO 8601 standard
     *
     * Days are the largest ISO duration supported, i.e.,
     * weeks, months, and years are not supported.
     *
     * @example
     * // This represents 1 day, 2 hours, 3 minutes, 4 seconds, and 567 milliseconds.
     * 'P1DT2H3M4.567S'
     *
     * @see https://www.iso.org/standard/70907.html
     * @param duration an ISO-formatted duration to be parsed.
     * @returns the parsed `Duration`.
     */
    static parse(duration: string): Duration;
    private readonly amount;
    private readonly unit;
    private constructor();
    /**
     * Add two Durations together
     */
    plus(rhs: Duration): Duration;
    /**
     * Substract two Durations together
     */
    minus(rhs: Duration): Duration;
    /**
     * Return the total number of milliseconds in this Duration
     *
     * @returns the value of this `Duration` expressed in Milliseconds.
     */
    toMilliseconds(opts?: TimeConversionOptions): number;
    /**
     * Return the total number of seconds in this Duration
     *
     * @returns the value of this `Duration` expressed in Seconds.
     */
    toSeconds(opts?: TimeConversionOptions): number;
    /**
     * Return the total number of minutes in this Duration
     *
     * @returns the value of this `Duration` expressed in Minutes.
     */
    toMinutes(opts?: TimeConversionOptions): number;
    /**
     * Return the total number of hours in this Duration
     *
     * @returns the value of this `Duration` expressed in Hours.
     */
    toHours(opts?: TimeConversionOptions): number;
    /**
     * Return the total number of days in this Duration
     *
     * @returns the value of this `Duration` expressed in Days.
     */
    toDays(opts?: TimeConversionOptions): number;
    /**
     * Return an ISO 8601 representation of this period
     *
     * @returns a string starting with 'P' describing the period
     * @see https://www.iso.org/standard/70907.html
     */
    toIsoString(): string;
    /**
     * Return an ISO 8601 representation of this period
     *
     * @returns a string starting with 'P' describing the period
     * @see https://www.iso.org/standard/70907.html
     * @deprecated Use `toIsoString()` instead.
     */
    toISOString(): string;
    /**
     * Turn this duration into a human-readable string
     */
    toHumanString(): string;
    /**
     * Returns a string representation of this `Duration`
     *
     * This is is never the right function to use when you want to use the `Duration`
     * object in a template. Use `toSeconds()`, `toMinutes()`, `toDays()`, etc. instead.
     */
    toString(): string;
    /**
     * Return the duration in a set of whole numbered time components, ordered from largest to smallest
     *
     * Only components != 0 will be returned.
     *
     * Can combine millis and seconds together for the benefit of toIsoString,
     * makes the logic in there simpler.
     */
    private components;
    /**
     * Checks if duration is a token or a resolvable object
     */
    isUnresolved(): boolean;
    /**
     * Returns unit of the duration
     */
    unitLabel(): string;
    /**
     * Returns stringified number of duration
     */
    formatTokenToNumber(): string;
}
/**
 * Options for how to convert time to a different unit.
 */
export interface TimeConversionOptions {
    /**
     * If `true`, conversions into a larger time unit (e.g. `Seconds` to `Minutes`) will fail if the result is not an
     * integer.
     *
     * @default true
     */
    readonly integral?: boolean;
}


../..//expiration
import { Duration } from "./duration";
/**
 * Represents a date of expiration.
 *
 * The amount can be specified either as a Date object, timestamp, Duration or string.
 */
export declare class Expiration {
    /**
     * Expire at the specified date
     * @param d date to expire at
     */
    static atDate(d: Date): Expiration;
    /**
     * Expire at the specified timestamp
     * @param t timestamp in unix milliseconds
     */
    static atTimestamp(t: number): Expiration;
    /**
     * Expire once the specified duration has passed since deployment time
     * @param t the duration to wait before expiring
     */
    static after(t: Duration): Expiration;
    /**
     * Expire at specified date, represented as a string
     *
     * @param s the string that represents date to expire at
     */
    static fromString(s: string): Expiration;
    /**
     * Expiration value as a Date object
     */
    readonly date: Date;
    private constructor();
    /**
     * Expiration Value in a formatted Unix Epoch Time in seconds
     */
    toEpoch(): number;
    /**
     * Check if Expiration expires before input
     * @param t the duration to check against
     */
    isBefore(t: Duration): boolean;
    /**
     * Check if Expiration expires after input
     * @param t the duration to check against
     */
    isAfter(t: Duration): boolean;
}


../..//size
/**
 * Represents the amount of digital storage.
 *
 * The amount can be specified either as a literal value (e.g: `10`) which
 * cannot be negative, or as an unresolved number token.
 *
 * When the amount is passed as a token, unit conversion is not possible.
 */
export declare class Size {
    /**
     * Create a Storage representing an amount bytes.
     *
     * @param amount the amount of bytes to be represented
     *
     * @returns a new `Size` instance
     */
    static bytes(amount: number): Size;
    /**
     * Create a Storage representing an amount kibibytes.
     * 1 KiB = 1024 bytes
     *
     * @param amount the amount of kibibytes to be represented
     *
     * @returns a new `Size` instance
     */
    static kibibytes(amount: number): Size;
    /**
     * Create a Storage representing an amount mebibytes.
     * 1 MiB = 1024 KiB
     *
     * @param amount the amount of mebibytes to be represented
     *
     * @returns a new `Size` instance
     */
    static mebibytes(amount: number): Size;
    /**
     * Create a Storage representing an amount gibibytes.
     * 1 GiB = 1024 MiB
     *
     * @param amount the amount of gibibytes to be represented
     *
     * @returns a new `Size` instance
     */
    static gibibytes(amount: number): Size;
    /**
     * Create a Storage representing an amount tebibytes.
     * 1 TiB = 1024 GiB
     *
     * @param amount the amount of tebibytes to be represented
     *
     * @returns a new `Size` instance
     */
    static tebibytes(amount: number): Size;
    /**
     * Create a Storage representing an amount pebibytes.
     * 1 PiB = 1024 TiB
     *
     * @deprecated use `pebibytes` instead
     */
    static pebibyte(amount: number): Size;
    /**
     * Create a Storage representing an amount pebibytes.
     * 1 PiB = 1024 TiB
     *
     * @param amount the amount of pebibytes to be represented
     *
     * @returns a new `Size` instance
     */
    static pebibytes(amount: number): Size;
    private readonly amount;
    private readonly unit;
    private constructor();
    /**
     * Return this storage as a total number of bytes.
     *
     * @param opts the conversion options
     *
     * @returns the quantity expressed in bytes
     */
    toBytes(opts?: SizeConversionOptions): number;
    /**
     * Return this storage as a total number of kibibytes.
     *
     * @param opts the conversion options
     *
     * @returns the quantity of bytes expressed in kibibytes
     */
    toKibibytes(opts?: SizeConversionOptions): number;
    /**
     * Return this storage as a total number of mebibytes.
     *
     * @param opts the conversion options
     *
     * @returns the quantity of bytes expressed in mebibytes
     */
    toMebibytes(opts?: SizeConversionOptions): number;
    /**
     * Return this storage as a total number of gibibytes.
     *
     * @param opts the conversion options
     *
     * @returns the quantity of bytes expressed in gibibytes
     */
    toGibibytes(opts?: SizeConversionOptions): number;
    /**
     * Return this storage as a total number of tebibytes.
     *
     * @param opts the conversion options
     *
     * @returns the quantity of bytes expressed in tebibytes
     */
    toTebibytes(opts?: SizeConversionOptions): number;
    /**
     * Return this storage as a total number of pebibytes.
     *
     * @param opts the conversion options
     *
     * @returns the quantity of bytes expressed in pebibytes
     */
    toPebibytes(opts?: SizeConversionOptions): number;
    /**
     * Checks if size is a token or a resolvable object
     */
    isUnresolved(): boolean;
}
/**
 * Rounding behaviour when converting between units of `Size`.
 */
export declare enum SizeRoundingBehavior {
    /** Fail the conversion if the result is not an integer. */
    FAIL = 0,
    /** If the result is not an integer, round it to the closest integer less than the result */
    FLOOR = 1,
    /** Don't round. Return even if the result is a fraction. */
    NONE = 2
}
/**
 * Options for how to convert time to a different unit.
 */
export interface SizeConversionOptions {
    /**
     * How conversions should behave when it encounters a non-integer result
     * @default SizeRoundingBehavior.FAIL
     */
    readonly rounding?: SizeRoundingBehavior;
}


../..//stack-base
import { TerraformStack, TerraformElement, HttpBackendConfig, HttpBackend } from "cdktf";
import { Construct, IConstruct, Node } from "constructs";
/**
 * Options for creating a unique resource name_prefix.
 */
export interface UniqueResourceNamePrefixOptions extends UniqueResourceNameOptions {
    /**
     * Length of the random generated suffix added by some Terraform providers.
     *
     * NOTE: https://github.com/hashicorp/terraform-provider-aws/issues/625
     * @default - 26
     */
    readonly suffixLength?: number;
}
/**
 * Options for creating a unique resource name.
 */
export interface UniqueResourceNameOptions {
    /**
     * The maximum length of the unique resource name.
     *
     * @default - 256
     */
    readonly maxLength?: number;
    /**
     * The separator used between the path components.
     *
     * @default - none
     */
    readonly separator?: string;
    /**
     * Non-alphanumeric characters allowed in the unique resource name.
     *
     * @default - none
     */
    readonly allowedSpecialCharacters?: string;
    /**
     * Prefix to be added into the stack name
     *
     * @default - none
     */
    readonly prefix?: string;
    /**
     * Whether to convert the resource name to lowercase.
     *
     * @default - false
     */
    readonly lowerCase?: boolean;
}
export interface StackBaseProps {
    /**
     * TerraConstruct UUID within the grid.
     *
     * UUID is generated by the CLI and ensures resource Identity
     * is decoupled from resource tagging for consistency.
     *
     * UUID may be user provided for imported resources
     */
    readonly gridUUID: string;
    /**
     * The environment name passed in from the CLI
     */
    readonly environmentName: string;
    /**
     * Stores the state using a simple REST client.
     *
     * State will be fetched via GET, updated via POST, and purged with DELETE.
     * The method used for updating is configurable.
     *
     * This backend optionally supports state locking.
     * When locking support is enabled it will use LOCK and UNLOCK requests providing the lock info in the body.
     * The endpoint should return a 423: Locked or 409: Conflict with the holding lock info when
     * it's already taken, 200: OK for success. Any other status will be considered an error.
     * The ID of the holding lock info will be added as a query parameter to state updates requests.
     *
     * Read more about this backend in the Terraform docs:
     * https://developer.hashicorp.com/terraform/language/settings/backends/http
     */
    readonly gridBackendConfig?: HttpBackendConfig;
}
export interface IStack extends IConstruct {
    /**
     * Environment Name passed in from the CLI
     */
    readonly environmentName: string;
    readonly gridUUID: string;
    readonly gridBackend?: HttpBackend;
    resolve(obj: any, preparing?: boolean): any;
    uniqueResourceName(tfElement: TerraformElement | Node, options?: UniqueResourceNameOptions): string;
    uniqueResourceNamePrefix(tfElement: TerraformElement | Node, options?: UniqueResourceNamePrefixOptions): string;
}
/**
 * Base class for all TerraConstructs stacks
 *
 * Provides a reference to the grid UUID and environment name
 */
export declare abstract class StackBase extends TerraformStack implements IStack {
    /**
     * Return whether the given object is a Stack.
     *
     * attribute detection since as 'instanceof' potentially fails across Library releases.
     */
    static isTerraStack(x: any): x is IStack;
    /**
     * Looks up the first stack scope in which `construct` is defined. Fails if there is no stack up the tree or the stack is not an IStack.
     * @param construct The construct to start the search from.
     */
    static ofTerraConstruct(construct: IConstruct): IStack;
    /**
     * Returns a unique identifier for a construct based on its path within
     * a TerraformStack. see uniqueResourceName, but with no separator, maximum length 255 and allows
     *  "_" and "-" on top of alphanumerical characters.
     *
     * @param construct The construct
     * @returns a unique resource name based on the construct path
     */
    static uniqueId(construct: IConstruct | Node): string;
    /**
     * Stack unique grid identifier
     */
    readonly gridUUID: string;
    /**
     * Environment Name passed in from the CLI
     */
    readonly environmentName: string;
    /**
     * The grid provided backend for state storage
     */
    readonly gridBackend?: HttpBackend;
    constructor(scope: Construct, id: string, props: StackBaseProps);
    /**
     * Returns a Terraform-compatible unique identifier for a Terraform Element based
     * on its path. This function finds the stackName of the parent stack (non-nested)
     * to the construct, and the ids of the components in the construct path.
     *
     * The user can define allowed special characters, a separator between the elements,
     * and the maximum length of the resource name. The name includes a human readable portion rendered
     * from the path components, with or without user defined separators, and a hash suffix.
     * If the resource name is longer than the maximum length, it is trimmed in the middle.
     *
     * @param tfElement The construct
     * @param options Options for defining the unique resource name
     * @returns a unique resource name based on the construct path
     */
    uniqueResourceName(tfElement: TerraformElement | Node, options?: UniqueResourceNameOptions): string;
    /**
     * Returns a Terraform-compatible unique identifier for a Terraform Element based
     * on its path. This function finds the stackName of the parent stack (non-nested)
     * to the construct, and the ids of the components in the construct path.
     *
     * The user can define allowed special characters, a separator between the elements,
     * and the maximum length of the resource name. The name includes a human readable portion rendered
     * from the path components, with or without user defined separators, and depends on the
     * resource provider to generate the random suffix.
     *
     * If the resource name is longer than the maximum length - suffixLength, it is trimmed in the middle.
     *
     * @param tfElement The construct
     * @param options Options for defining the unique resource name
     * @returns a unique resource name based on the construct path
     */
    uniqueResourceNamePrefix(tfElement: TerraformElement | Node, options?: UniqueResourceNamePrefixOptions): string;
    /** Resolve IResolvable in scope of this AwsStack */
    resolve(obj: any, preparing?: boolean): any;
    /**
     * Convert an object, potentially containing tokens, to a JSON string
     */
    toJsonString(obj: any, space?: number): string;
}


../..//terra-func
import { TerraformVariableConfig, Fn as tfFn } from "cdktf";
import { Construct } from "constructs";
/**
 * TerraConstructs helper functions.
 */
export declare class Fn extends tfFn {
    /**
     * Split a string token into a token list of string values.
     *
     * Specify the location of splits with a delimiter such as ',' (a comma).
     * Renders to the `split` intrinsic terraform function.
     *
     * Lists with unknown lengths (default)
     * -------------------------------------
     *
     * Since this function is used to work with deploy-time values, if `assumedLength`
     * is not given the CDK cannot know the length of the resulting list at synthesis time.
     * This brings the following restrictions:
     *
     * - You must use `Fn.element(list, i)` to pick elements out of the list (you must not use
     *   `list[i]`).
     * - You cannot add elements to the list, remove elements from the list,
     *   combine two such lists together, or take a slice of the list.
     * - You cannot pass the list to constructs that do any of the above.
     *
     * The only valid operation with such a tokenized list is to pass it unmodified to a
     * Terraform Resource construct.
     *
     * Lists with assumed lengths
     * --------------------------
     *
     * Pass `assumedLength` if you know the length of the list that will be
     * produced by splitting. The actual list length at deploy time may be
     * *longer* than the number you pass, but not *shorter*.
     *
     * The returned list will look like:
     *
     * ```
     * [Fn.element(split, 0), Fn.element(split, 1), Fn.element(split, 2), ...]
     * ```
     *
     * The restrictions from the section "Lists with unknown lengths" will now be lifted,
     * at the expense of having to know and fix the length of the list.
     *
     * @param delimiter A string value that determines where the source string is divided.
     * @param source The string value that you want to split.
     * @param assumedLength The length of the list that will be produced by splitting
     * @returns a token represented as a string array
     */
    static splitv2(delimiter: string, source: string, assumedLength?: number): string[];
    /**
     * Similar to Fn.element, but with a shortcut if list is not unresolved
     *
     * The intrinsic function ``element`` returns a single object from a list of objects by index.
     * @param index The index of the object to retrieve. This must be a value from zero to N-1, where N represents the number of elements in the array.
     * @param array The list of objects to select from. This list must not be null, nor can it have null entries.
     * @returns a token represented as a string
     */
    static select(index: number, array: string[]): string;
    /**
     * Given an url, parse the domain name
     * @param url the url to parse
     */
    static parseDomainName(url: string): string;
    /**
     * The intrinsic function ``Fn::ImportValue`` returns the value of an output
     * exported by another stack. You typically use this function to create
     * cross-stack references. In the following example template snippets, Stack A
     * exports VPC security group values and Stack B imports them.
     * @param id The stack output value that you want to import.
     * @returns a token represented as a string
     */
    static importValue(scope: Construct, id: string, options?: TerraformVariableConfig): string;
    /**
     * Like `Fn.importValue`, but import a list with a known length
     *
     * If you explicitly want a list with an unknown length, call `Fn.splitv2(',',
     * Fn.importValue(scope, exportName))`. See the documentation of `Fn.splitv2` to read
     * more about the limitations of using lists of unknown length.
     *
     * `Fn.importListValue(scope, exportName, assumedLength)` is the same as
     * `Fn.split(',', Fn.importValue(scope, exportName), assumedLength)`,
     * but easier to read and impossible to forget to pass `assumedLength`.
     */
    static importListValue(scope: Construct, sharedValueToImport: string, assumedLength: number, delimiter?: string): string[];
    /**
     * The intrinsic function `Fn::Length` returns the number of elements within an array
     * or an intrinsic function that returns an array.
     *
     * @param array The array you want to return the number of elements from
     */
    static len(array: any): number;
    /**
     * {@link https://developer.hashicorp.com/terraform/language/functions/join join} produces a string by concatenating together all elements of a given list of strings with the given delimiter.
     *
     * If any of the values are unresolved, the intrinsic function will be used.
     * if the list has only one element, the element will be returned.
     * if the list has more than one element, the elements will be joined with the delimiter.
     * @param {string} delimiter
     * @param {Array<string>} values
     */
    static join(delimiter: string, values: string[]): string;
}


../..//token
/**
 * An enum-like class that represents the result of comparing two Tokens.
 * The return type of `Token.compareStrings`.
 */
export declare class TokenComparison {
    /**
     * This means we're certain the two components are NOT
     * Tokens, and identical.
     */
    static readonly SAME: TokenComparison;
    /**
     * This means we're certain the two components are NOT
     * Tokens, and different.
     */
    static readonly DIFFERENT: TokenComparison;
    /** This means exactly one of the components is a Token. */
    static readonly ONE_UNRESOLVED: TokenComparison;
    /** This means both components are Tokens. */
    static readonly BOTH_UNRESOLVED: TokenComparison;
    private constructor();
}
/** Compare two strings that might contain Tokens with each other. */
export declare function tokenCompareStrings(possibleToken1: string, possibleToken2: string): TokenComparison;
/**
 * Call the given function only if all given values are resolved
 *
 * Exported as a function since it will be used by TypeScript modules, but
 * can't be exposed via JSII because of the generics.
 */
export declare function withResolved<A>(a: A, fn: (a: A) => void): void;
export declare function withResolved<A, B>(a: A, b: B, fn: (a: A, b: B) => void): void;
export declare function withResolved<A, B, C>(a: A, b: B, c: C, fn: (a: A, b: B, c: C) => void): void;

```

**TerraConstructs AWS Utility Declarations**
```typescript
// ..//arn
import { IAwsStack } from "./aws-stack";
/**
 * An enum representing the various ARN formats that different services use.
 */
export declare enum ArnFormat {
    /**
     * This represents a format where there is no 'resourceName' part.
     * This format is used for S3 resources,
     * like 'arn:aws:s3:::bucket'.
     * Everything after the last colon is considered the 'resource',
     * even if it contains slashes,
     * like in 'arn:aws:s3:::bucket/object.zip'.
     */
    NO_RESOURCE_NAME = "arn:aws:service:region:account:resource",
    /**
     * This represents a format where the 'resource' and 'resourceName'
     * parts are separated with a colon.
     * Like in: 'arn:aws:service:region:account:resource:resourceName'.
     * Everything after the last colon is considered the 'resourceName',
     * even if it contains slashes,
     * like in 'arn:aws:apigateway:region:account:resource:/test/mydemoresource/*'.
     */
    COLON_RESOURCE_NAME = "arn:aws:service:region:account:resource:resourceName",
    /**
     * This represents a format where the 'resource' and 'resourceName'
     * parts are separated with a slash.
     * Like in: 'arn:aws:service:region:account:resource/resourceName'.
     * Everything after the separating slash is considered the 'resourceName',
     * even if it contains colons,
     * like in 'arn:aws:cognito-sync:region:account:identitypool/us-east-1:1a1a1a1a-ffff-1111-9999-12345678:bla'.
     */
    SLASH_RESOURCE_NAME = "arn:aws:service:region:account:resource/resourceName",
    /**
     * This represents a format where the 'resource' and 'resourceName'
     * parts are seperated with a slash,
     * but there is also an additional slash after the colon separating 'account' from 'resource'.
     * Like in: 'arn:aws:service:region:account:/resource/resourceName'.
     * Note that the leading slash is _not_ included in the parsed 'resource' part.
     */
    SLASH_RESOURCE_SLASH_RESOURCE_NAME = "arn:aws:service:region:account:/resource/resourceName"
}
export interface ArnComponents {
    /**
     * The partition that the resource is in. For standard AWS regions, the
     * partition is aws. If you have resources in other partitions, the
     * partition is aws-partitionname. For example, the partition for resources
     * in the China (Beijing) region is aws-cn.
     *
     * @default The AWS partition the stack is deployed to.
     */
    readonly partition?: string;
    /**
     * The service namespace that identifies the AWS product (for example,
     * 's3', 'iam', 'codepipline').
     */
    readonly service: string;
    /**
     * The region the resource resides in. Note that the ARNs for some resources
     * do not require a region, so this component might be omitted.
     *
     * @default The region the stack is deployed to.
     */
    readonly region?: string;
    /**
     * The ID of the AWS account that owns the resource, without the hyphens.
     * For example, 123456789012. Note that the ARNs for some resources don't
     * require an account number, so this component might be omitted.
     *
     * @default The account the stack is deployed to.
     */
    readonly account?: string;
    /**
     * Resource type (e.g. "table", "autoScalingGroup", "certificate").
     * For some resource types, e.g. S3 buckets, this field defines the bucket name.
     */
    readonly resource: string;
    /**
     * Separator between resource type and the resource.
     *
     * Can be either '/', ':' or an empty string. Will only be used if resourceName is defined.
     * @default '/'
     *
     * @deprecated use arnFormat instead
     */
    readonly sep?: string;
    /**
     * Resource name or path within the resource (i.e. S3 bucket object key) or
     * a wildcard such as ``"*"``. This is service-dependent.
     */
    readonly resourceName?: string;
    /**
     * The specific ARN format to use for this ARN value.
     *
     * @default - uses value of `sep` as the separator for formatting,
     *   `ArnFormat.SLASH_RESOURCE_NAME` if that property was also notd
     */
    readonly arnFormat?: ArnFormat;
}
export declare class Arn {
    /**
     * Creates an ARN from components.
     *
     * If `partition`, `region` or `account` are not specified, the stack's
     * partition, region and account will be used.
     *
     * If any component is the empty string, an empty string will be inserted
     * into the generated ARN at the location that component corresponds to.
     *
     * The ARN will be formatted as follows:
     *
     *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}{resource-name}
     *
     * The required ARN pieces that are omitted will be taken from the stack that
     * the 'scope' is attached to. If all ARN pieces are supplied, the supplied scope
     * can be 'undefined'.
     */
    static format(components: ArnComponents, stack?: IAwsStack): string;
    /**
     * Given an ARN, parses it and returns components.
     *
     * IF THE ARN IS A CONCRETE STRING...
     *
     * ...it will be parsed and validated. The separator (`sep`) will be set to '/'
     * if the 6th component includes a '/', in which case, `resource` will be set
     * to the value before the '/' and `resourceName` will be the rest. In case
     * there is no '/', `resource` will be set to the 6th components and
     * `resourceName` will be set to the rest of the string.
     *
     * IF THE ARN IS A TOKEN...
     *
     * ...it cannot be validated, since we don't have the actual value yet at the
     * time of this function call. You will have to supply `sepIfToken` and
     * whether or not ARNs of the expected format usually have resource names
     * in order to parse it properly. The resulting `ArnComponents` object will
     * contain tokens for the subexpressions of the ARN, not string literals.
     *
     * If the resource name could possibly contain the separator char, the actual
     * resource name cannot be properly parsed. This only occurs if the separator
     * char is '/', and happens for example for S3 object ARNs, IAM Role ARNs,
     * IAM OIDC Provider ARNs, etc. To properly extract the resource name from a
     * Tokenized ARN, you must know the resource type and call
     * `Arn.extractResourceName`.
     *
     * @param arn The ARN to parse
     * @param sepIfToken The separator used to separate resource from resourceName
     * @param hasName Whether there is a name component in the ARN at all. For
     * example, SNS Topics ARNs have the 'resource' component contain the topic
     * name, and no 'resourceName' component.
     *
     * @returns an ArnComponents object which allows access to the various
     * components of the ARN.
     *
     * @returns an ArnComponents object which allows access to the various
     *      components of the ARN.
     *
     * @deprecated use split instead
     */
    static parse(arn: string, sepIfToken?: string, hasName?: boolean): ArnComponents;
    /**
     * Splits the provided ARN into its components.
     * Works both if 'arn' is a string like 'arn:aws:s3:::bucket',
     * and a Token representing a dynamic CloudFormation expression
     * (in which case the returned components will also be dynamic CloudFormation expressions,
     * encoded as Tokens).
     *
     * @param arn the ARN to split into its components
     * @param arnFormat the expected format of 'arn' - depends on what format the service 'arn' represents uses
     */
    static split(arn: string, arnFormat: ArnFormat): ArnComponents;
    /**
     * Extract the full resource name from an ARN
     *
     * Necessary for resource names (paths) that may contain the separator, like
     * `arn:aws:iam::111111111111:role/path/to/role/name`.
     *
     * Only works if we statically know the expected `resourceType` beforehand, since we're going
     * to use that to split the string on ':<resourceType>/' (and take the right-hand side).
     *
     * We can't extract the 'resourceType' from the ARN at hand, because CloudFormation Expressions
     * only allow literals in the 'separator' argument to `{ Fn::Split }`, and so it can't be
     * `{ Fn::Select: [5, { Fn::Split: [':', ARN] }}`.
     *
     * Only necessary for ARN formats for which the type-name separator is `/`.
     */
    static extractResourceName(arn: string, resourceType: string): string;
    private constructor();
}


// ..//aws-construct
import { Construct } from "constructs";
import { AwsStack } from "./aws-stack";
import { TerraConstructBase, TerraConstructProps, ITerraConstruct } from "../construct-base";
/**
 * Represents the environment a given AwsConstruct lives in.
 * Used as the return value for the `IResource.env` property.
 */
export interface AwsEnvironment {
    /**
     * The AWS partition that this resource belongs to.
     */
    readonly partition: string;
    /**
     * The AWS account ID that this resource belongs to.
     */
    readonly account: string;
    /**
     * The AWS region that this resource belongs to.
     */
    readonly region: string;
}
/**
 * Represents an AWS resource similar to the AWS CDK `Resource` class but backed by CDKTF.
 */
export interface IAwsConstruct extends ITerraConstruct {
    /**
     * The stack into which this resource is constructed by the TerraConstruct.
     */
    readonly stack: AwsStack;
    /**
     * The environment this resource belongs to.
     * For resources that are created and managed by the CDKTF
     * (generally, those created by creating new class instances like Environment, EcsDeployment, etc.),
     * this is always the same as the environment of the stack they belong to;
     * however, for imported resources
     * (those obtained from static methods like fromRoleArn, fromBucketName, etc.),
     * that might be different than the stack they were imported into.
     */
    readonly env: AwsEnvironment;
}
/**
 * Construction properties for `Resource`.
 */
export interface AwsConstructProps extends TerraConstructProps {
    /**
     * The AWS account ID this resource belongs to.
     *
     * @default - the resource is in the same account as the stack it belongs to
     */
    readonly account?: string;
    /**
     * The AWS region this resource belongs to.
     *
     * @default - the resource is in the same region as the stack it belongs to
     */
    readonly region?: string;
    /**
     * ARN to deduce region and account from
     *
     * The ARN is parsed and the account and region are taken from the ARN.
     * This should be used for imported resources.
     *
     * Cannot be supplied together with either `account` or `region`.
     *
     * @default - take environment from `account`, `region` parameters, or use Stack environment.
     */
    readonly environmentFromArn?: string;
}
/**
 * Represents an AWS resource similar to the AWS CDK `Resource` class but backed by CDKTF.
 */
export declare abstract class AwsConstructBase extends TerraConstructBase implements IAwsConstruct {
    readonly stack: AwsStack;
    readonly env: AwsEnvironment;
    constructor(scope: Construct, id: string, props?: AwsConstructProps);
}


// ..//aws-stack
import { provider } from "@cdktf/provider-aws";
import { ResourceTerraformIterator } from "cdktf";
import { Construct, IConstruct } from "constructs";
import { ArnComponents, ArnFormat } from "./arn";
import { AwsProviderConfig } from "./provider-config.generated";
import { StackBaseProps, StackBase, IStack } from "../stack-base";
export interface AwsStackProps extends StackBaseProps {
    /**
     * The AWS Provider configuration (without the alias field)
     */
    readonly providerConfig: AwsProviderConfig;
}
export interface IAwsStack extends IStack {
    /**
     * The AWS Region for the TerraConstruct
     */
    readonly region: string;
    /**
     * The AWS Account for the TerraConstruct
     */
    readonly account: string;
    /**
     * The AWS Partition for the TerraConstruct
     */
    readonly partition: string;
    /**
     * The service Principal Id for a specific service
     *
     * @param serviceName The service name to get the service principal ID for
     * @param region The region to get the service principal ID for
     */
    servicePrincipalName(serviceName: string, region?: string): string;
}
/**
 * A Terraform stack constrained to a single AWS Account/Region to simulate CFN behavior.
 */
export declare class AwsStack extends StackBase implements IAwsStack {
    /**
     * Return whether the given object is a Stack.
     *
     * attribute detection since as 'instanceof' potentially fails across Library releases.
     */
    static isAwsStack(x: any): x is AwsStack;
    /**
     * Looks up the first stack scope in which `construct` is defined. Fails if there is no stack up the tree or the stack is not an AwsStack.
     * @param construct The construct to start the search from.
     */
    static ofAwsConstruct(construct: IConstruct): AwsStack;
    private readonly lookup;
    private regionalAwsProviders;
    /**
     * Cache these tokens for reliable comparisons.
     *
     * Every call for the same Token will produce a new unique string, no
     * attempt is made to deduplicate. Token objects should cache the
     * value themselves, if required.
     *
     * dataSource.getSTringattribute -> Token.asString -> tokenMap.registerString
     * ref:
     * - https://github.com/hashicorp/terraform-cdk/blob/v0.20.10/packages/cdktf/lib/terraform-data-source.ts#L68
     * - https://github.com/hashicorp/terraform-cdk/blob/v0.20.10/packages/cdktf/lib/tokens/private/token-map.ts#L50-L66
     */
    private _accountIdToken;
    private _paritionToken;
    private _urlSuffixToken;
    constructor(scope: Construct, id: string, props: AwsStackProps);
    get provider(): provider.AwsProvider;
    /**
     * Get the Region of the AWS Stack
     */
    get region(): string;
    private get dataAwsCallerIdentity();
    private get dataAwsAvailabilityZones();
    private get dataAwsPartition();
    private getRegionalAwsProvider;
    /**
     * Get the Account of the AWS Stack
     */
    get account(): string;
    /**
     * Get the Partition of the AWS Stack
     */
    get partition(): string;
    /**
     * Base DNS domain name for the current partition (e.g., amazonaws.com in AWS Commercial, amazonaws.com.cn in AWS China).
     */
    get urlSuffix(): string;
    /**
     * Return the service principal name based on the region it's used in.
     *
     * Some service principal names used to be different for different partitions,
     * and some were not.
     *
     * These days all service principal names are standardized, and they are all
     * of the form `<servicename>.amazonaws.com`.
     *
     * To avoid breaking changes, handling is provided for services added with the formats below,
     * however, no additional handling will be added for new regions or partitions.
     *   - s3
     *   - s3.amazonaws.com
     *   - s3.amazonaws.com.cn
     *   - s3.c2s.ic.gov
     *   - s3.sc2s.sgov.gov
     *
     * @param service The service name to get the service principal ID for
     * @param region The region to get the service principal ID for
     */
    servicePrincipalName(service: string, region?: string): string;
    /**
     * Creates an ARN from components.
     *
     * If `partition`, `region` or `account` are not specified, the stack's
     * partition, region and account will be used.
     *
     * If any component is the empty string, an empty string will be inserted
     * into the generated ARN at the location that component corresponds to.
     *
     * The ARN will be formatted as follows:
     *
     *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}{resource-name}
     *
     * The required ARN pieces that are omitted will be taken from the stack that
     * the 'scope' is attached to. If all ARN pieces are supplied, the supplied scope
     * can be 'undefined'.
     */
    formatArn(components: ArnComponents): string;
    /**
     * Given an ARN, parses it and returns components.
     *
     * IF THE ARN IS A CONCRETE STRING...
     *
     * ...it will be parsed and validated. The separator (`sep`) will be set to '/'
     * if the 6th component includes a '/', in which case, `resource` will be set
     * to the value before the '/' and `resourceName` will be the rest. In case
     * there is no '/', `resource` will be set to the 6th components and
     * `resourceName` will be set to the rest of the string.
     *
     * IF THE ARN IS A TOKEN...
     *
     * ...it cannot be validated, since we don't have the actual value yet at the
     * time of this function call. You will have to supply `sepIfToken` and
     * whether or not ARNs of the expected format usually have resource names
     * in order to parse it properly. The resulting `ArnComponents` object will
     * contain tokens for the subexpressions of the ARN, not string literals.
     *
     * If the resource name could possibly contain the separator char, the actual
     * resource name cannot be properly parsed. This only occurs if the separator
     * char is '/', and happens for example for S3 object ARNs, IAM Role ARNs,
     * IAM OIDC Provider ARNs, etc. To properly extract the resource name from a
     * Tokenized ARN, you must know the resource type and call
     * `Arn.extractResourceName`.
     *
     * @param arn The ARN string to parse
     * @param sepIfToken The separator used to separate resource from resourceName
     * @param hasName Whether there is a name component in the ARN at all. For
     * example, SNS Topics ARNs have the 'resource' component contain the topic
     * name, and no 'resourceName' component.
     *
     * @returns an ArnComponents object which allows access to the various
     * components of the ARN.
     *
     * @returns an ArnComponents object which allows access to the various
     *      components of the ARN.
     *
     * @deprecated use splitArn instead
     */
    parseArn(arn: string, sepIfToken?: string, hasName?: boolean): ArnComponents;
    /**
     * Splits the provided ARN into its components.
     * Works both if 'arn' is a string like 'arn:aws:s3:::bucket',
     * and a Token representing a dynamic CloudFormation expression
     * (in which case the returned components will also be dynamic CloudFormation expressions,
     * encoded as Tokens).
     *
     * @param arn the ARN to split into its components
     * @param arnFormat the expected format of 'arn' - depends on what format the service 'arn' represents uses
     */
    splitArn(arn: string, arnFormat: ArnFormat): ArnComponents;
    /**
     * Returns iterator for all AZs that are available in the AWS environment
     * (account/region) associated with this stack (default or aliased provider).
     *
     * this will return a cdktf iterator
     *
     * https://developer.hashicorp.com/terraform/cdktf/concepts/iterators#define-iterators
     *
     * To specify a different strategy for selecting availability zones override this method.
     */
    get availabilityZoneIterator(): ResourceTerraformIterator;
    /**
     * Returns a List of Tokens for AZ names available in the stack's
     * AWS environment (account/region).
     *
     * The list length is `maxCount` which defaults to 2.
     *
     * @param maxCount the maximum number of AZs to return
     */
    availabilityZones(maxCount?: number): string[];
}


// ..//aws-tags
import { IAspect } from "cdktf";
import { IConstruct } from "constructs";
import { TaggableConstruct } from "../construct-base";
/**
 * TaggableConstruct is a Construct that can have tags
 */
export declare function isTaggableConstruct(x: IConstruct): x is TaggableConstruct;
/**
 * Properties for a tag
 */
export interface TagProps {
    /**
     * An array of Resource Types that will not receive this tag
     *
     * An empty array will allow this tag to be applied to all resources. A
     * non-empty array will apply this tag only if the Resource type is not in
     * this array.
     * @default []
     */
    readonly excludeResourceTypes?: string[];
    /**
     * An array of Resource Types that will receive this tag
     *
     * An empty array will match any Resource. A non-empty array will apply this
     * tag only to Resource types that are included in this array.
     * @default []
     */
    readonly includeResourceTypes?: string[];
}
/**
 * CDKTF Aspect adding a single Key/Value Tag to all resources within a construct scope
 *
 * Add tags using `Tags.of(scope).add(key, value)`
 */
export declare class AwsTag implements IAspect {
    private key;
    private value;
    private readonly props;
    constructor(key: string, value: string, props?: TagProps);
    visit(node: IConstruct): void;
    private applyTagAspectHere;
}
/**
 * Manages AWS tags for all resources within a construct scope.
 */
export declare class Tags {
    private readonly scope;
    /**
     * Returns the tags API for this scope.
     * @param scope The scope
     */
    static of(scope: IConstruct): Tags;
    private constructor();
    /**
     * add tags to the node of a construct and all its the taggable children
     */
    add(key: string, value: string, props?: TagProps): void;
}


// ..//log-retention
/**
 * How long, in days, the log contents will be retained.
 */
export declare enum RetentionDays {
    /**
     * 1 day
     */
    ONE_DAY = 1,
    /**
     * 3 days
     */
    THREE_DAYS = 3,
    /**
     * 5 days
     */
    FIVE_DAYS = 5,
    /**
     * 1 week
     */
    ONE_WEEK = 7,
    /**
     * 2 weeks
     */
    TWO_WEEKS = 14,
    /**
     * 1 month
     */
    ONE_MONTH = 30,
    /**
     * 2 months
     */
    TWO_MONTHS = 60,
    /**
     * 3 months
     */
    THREE_MONTHS = 90,
    /**
     * 4 months
     */
    FOUR_MONTHS = 120,
    /**
     * 5 months
     */
    FIVE_MONTHS = 150,
    /**
     * 6 months
     */
    SIX_MONTHS = 180,
    /**
     * 1 year
     */
    ONE_YEAR = 365,
    /**
     * 13 months
     */
    THIRTEEN_MONTHS = 400,
    /**
     * 18 months
     */
    EIGHTEEN_MONTHS = 545,
    /**
     * 2 years
     */
    TWO_YEARS = 731,
    /**
     * 3 years
     */
    THREE_YEARS = 1096,
    /**
     * 5 years
     */
    FIVE_YEARS = 1827,
    /**
     * 6 years
     */
    SIX_YEARS = 2192,
    /**
     * 7 years
     */
    SEVEN_YEARS = 2557,
    /**
     * 8 years
     */
    EIGHT_YEARS = 2922,
    /**
     * 9 years
     */
    NINE_YEARS = 3288,
    /**
     * 10 years
     */
    TEN_YEARS = 3653,
    /**
     * Retain logs forever
     */
    INFINITE = 9999
}


// ..//provider-config.generated
import type { IResolvable } from 'cdktf';
import type { provider } from '@cdktf/provider-aws';
/**
 * Config for the AWS Provider
 */
export interface AwsProviderConfig {
    /**
     * Resolve an endpoint with FIPS capability.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#use_fips_endpoint AwsProvider#use_fips_endpoint}
     * @stability stable
     */
    readonly useFipsEndpoint?: boolean | IResolvable;
    /**
     * Resolve an endpoint with DualStack capability.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#use_dualstack_endpoint AwsProvider#use_dualstack_endpoint}
     * @stability stable
     */
    readonly useDualstackEndpoint?: boolean | IResolvable;
    /**
     * The capacity of the AWS SDK's token bucket rate limiter.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#token_bucket_rate_limiter_capacity AwsProvider#token_bucket_rate_limiter_capacity}
     * @stability stable
     */
    readonly tokenBucketRateLimiterCapacity?: number;
    /**
     * session token. A session token is only required if you are using temporary security credentials.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#token AwsProvider#token}
     * @stability stable
     */
    readonly token?: string;
    /**
     * The region where AWS STS operations will take place. Examples are us-east-1 and us-west-2.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#sts_region AwsProvider#sts_region}
     * @stability stable
     */
    readonly stsRegion?: string;
    /**
     * Skip requesting the account ID. Used for AWS API implementations that do not have IAM/STS API and/or metadata API.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#skip_requesting_account_id AwsProvider#skip_requesting_account_id}
     * @stability stable
     */
    readonly skipRequestingAccountId?: boolean | IResolvable;
    /**
     * Skip static validation of region name.
     * Used by users of alternative AWS-like APIs or users w/ access to regions that are not public (yet).
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#skip_region_validation AwsProvider#skip_region_validation}
     * @stability stable
     */
    readonly skipRegionValidation?: boolean | IResolvable;
    /**
     * Skip the AWS Metadata API check. Used for AWS API implementations that do not have a metadata api endpoint.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#skip_metadata_api_check AwsProvider#skip_metadata_api_check}
     * @stability stable
     */
    readonly skipMetadataApiCheck?: string;
    /**
     * Skip the credentials validation via STS API. Used for AWS API implementations that do not have STS available/implemented.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#skip_credentials_validation AwsProvider#skip_credentials_validation}
     * @stability stable
     */
    readonly skipCredentialsValidation?: boolean | IResolvable;
    /**
     * List of paths to shared credentials files. If not set, defaults to [~/.aws/credentials].
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#shared_credentials_files AwsProvider#shared_credentials_files}
     * @stability stable
     */
    readonly sharedCredentialsFiles?: Array<string>;
    /**
     * List of paths to shared config files. If not set, defaults to [~/.aws/config].
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#shared_config_files AwsProvider#shared_config_files}
     * @stability stable
     */
    readonly sharedConfigFiles?: Array<string>;
    /**
     * The secret key for API operations. You can retrieve this from the 'Security & Credentials' section of the AWS console.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#secret_key AwsProvider#secret_key}
     * @stability stable
     */
    readonly secretKey?: string;
    /**
     * Set this to true to enable the request to use path-style addressing, i.e., https://s3.amazonaws.com/BUCKET/KEY. By default, the S3 client will use virtual hosted bucket addressing when possible (https://BUCKET.s3.amazonaws.com/KEY). Specific to the Amazon S3 service.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#s3_use_path_style AwsProvider#s3_use_path_style}
     * @stability stable
     */
    readonly s3UsePathStyle?: boolean | IResolvable;
    /**
     * Specifies whether S3 API calls in the `us-east-1` region use the legacy global endpoint or a regional endpoint.
     * Valid values are `legacy` or `regional`. Can also be configured using the `AWS_S3_US_EAST_1_REGIONAL_ENDPOINT` environment variable or the `s3_us_east_1_regional_endpoint` shared config file parameter
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#s3_us_east_1_regional_endpoint AwsProvider#s3_us_east_1_regional_endpoint}
     * @stability stable
     */
    readonly s3UsEast1RegionalEndpoint?: string;
    /**
     * Specifies how retries are attempted.
     * Valid values are `standard` and `adaptive`. Can also be configured using the `AWS_RETRY_MODE` environment variable.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#retry_mode AwsProvider#retry_mode}
     * @stability stable
     */
    readonly retryMode?: string;
    /**
     * The region where AWS operations will take place. Examples are us-east-1, us-west-2, etc.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#region AwsProvider#region}
     * @stability stable
     */
    readonly region?: string;
    /**
     * The profile for API operations. If not set, the default profile created with `aws configure` will be used.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#profile AwsProvider#profile}
     * @stability stable
     */
    readonly profile?: string;
    /**
     * Comma-separated list of hosts that should not use HTTP or HTTPS proxies.
     * Can also be set using the `NO_PROXY` or `no_proxy` environment variables.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#no_proxy AwsProvider#no_proxy}
     * @stability stable
     */
    readonly noProxy?: string;
    /**
     * The maximum number of times an AWS API request is being executed.
     * If the API request still fails, an error is
     * thrown.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#max_retries AwsProvider#max_retries}
     * @stability stable
     */
    readonly maxRetries?: number;
    /**
     * Explicitly allow the provider to perform "insecure" SSL requests. If omitted, default value is `false`.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#insecure AwsProvider#insecure}
     * @stability stable
     */
    readonly insecure?: boolean | IResolvable;
    /**
     * ignore_tags block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#ignore_tags AwsProvider#ignore_tags}
     * @stability stable
     */
    readonly ignoreTags?: IResolvable | Array<provider.AwsProviderIgnoreTags>;
    /**
     * URL of a proxy to use for HTTPS requests when accessing the AWS API.
     * Can also be set using the `HTTPS_PROXY` or `https_proxy` environment variables.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#https_proxy AwsProvider#https_proxy}
     * @stability stable
     */
    readonly httpsProxy?: string;
    /**
     * URL of a proxy to use for HTTP requests when accessing the AWS API.
     * Can also be set using the `HTTP_PROXY` or `http_proxy` environment variables.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#http_proxy AwsProvider#http_proxy}
     * @stability stable
     */
    readonly httpProxy?: string;
    /**
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#forbidden_account_ids AwsProvider#forbidden_account_ids}.
     * @stability stable
     */
    readonly forbiddenAccountIds?: Array<string>;
    /**
     * endpoints block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#endpoints AwsProvider#endpoints}
     * @stability stable
     */
    readonly endpoints?: IResolvable | Array<provider.AwsProviderEndpoints>;
    /**
     * Protocol to use with EC2 metadata service endpoint.Valid values are `IPv4` and `IPv6`. Can also be configured using the `AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE` environment variable.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#ec2_metadata_service_endpoint_mode AwsProvider#ec2_metadata_service_endpoint_mode}
     * @stability stable
     */
    readonly ec2MetadataServiceEndpointMode?: string;
    /**
     * Address of the EC2 metadata service endpoint to use. Can also be configured using the `AWS_EC2_METADATA_SERVICE_ENDPOINT` environment variable.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#ec2_metadata_service_endpoint AwsProvider#ec2_metadata_service_endpoint}
     * @stability stable
     */
    readonly ec2MetadataServiceEndpoint?: string;
    /**
     * default_tags block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#default_tags AwsProvider#default_tags}
     * @stability stable
     */
    readonly defaultTags?: IResolvable | Array<provider.AwsProviderDefaultTags>;
    /**
     * File containing custom root and intermediate certificates.
     * Can also be configured using the `AWS_CA_BUNDLE` environment variable. (Setting `ca_bundle` in the shared config file is not supported.)
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#custom_ca_bundle AwsProvider#custom_ca_bundle}
     * @stability stable
     */
    readonly customCaBundle?: string;
    /**
     * assume_role_with_web_identity block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#assume_role_with_web_identity AwsProvider#assume_role_with_web_identity}
     * @stability stable
     */
    readonly assumeRoleWithWebIdentity?: IResolvable | Array<provider.AwsProviderAssumeRoleWithWebIdentity>;
    /**
     * assume_role block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#assume_role AwsProvider#assume_role}
     * @stability stable
     */
    readonly assumeRole?: IResolvable | Array<provider.AwsProviderAssumeRole>;
    /**
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#allowed_account_ids AwsProvider#allowed_account_ids}.
     * @stability stable
     */
    readonly allowedAccountIds?: Array<string>;
    /**
     * The access key for API operations. You can retrieve this from the 'Security & Credentials' section of the AWS console.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#access_key AwsProvider#access_key}
     * @stability stable
     */
    readonly accessKey?: string;
}


// ..//util
/**
 * Returns a copy of `obj` without `undefined` (or `null`) values in maps or arrays.
 */
export declare function filterUndefined(obj: any): any;

```

## Steps

1. **Review Input**: Examine the provided TypeScript code using AWS CDK Constructs (prefixed with Cfn..).
2. **Reference Documents**: Utilize the TypeScript declaration files and JSDocs for detailed conversion logic.
3. **Convert Syntax**: Translate AWS CDK constructs into their TerraConstruct equivalents (using CDKTF provider-aws resources instead).
4. **Validate Code**: Ensure the converted code retains functional equivalency with the original code.
5. **Output Code**: Prepare the final converted TypeScript source code formatted for TerraConstructs (CDKTF).

## Output Format

- Generate a TypeScript source code file (.ts) formatted for CDKTF.
- Ensure the file is syntactically correct and ready for writing to disk.
- put the source code between triple back ticks ("```")

## Examples

**Example 1:**
**Input**:
```typescript
import { Construct } from 'constructs';
import { Archive, BaseArchiveProps } from './archive';
import { CfnEventBus, CfnEventBusPolicy } from './events.generated';
import * as iam from '../../aws-iam';
import * as kms from '../../aws-kms';
import * as sqs from '../../aws-sqs';
import { ArnFormat, IResource, Lazy, Names, Resource, Stack, Token } from '../../core';

/**
 * Interface which all EventBus based classes MUST implement
 */
export interface IEventBus extends IResource {
  /**
   * The physical ID of this event bus resource
   *
   * @attribute
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
   */
  readonly eventBusName: string;

  /**
   * The ARN of this event bus resource
   *
   * @attribute
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Arn-fn::getatt
   */
  readonly eventBusArn: string;

  /**
   * The JSON policy of this event bus resource
   *
   * @attribute
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Policy-fn::getatt
   */
  readonly eventBusPolicy: string;

  /**
   * The partner event source to associate with this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
   */
  readonly eventSourceName?: string;

  /**
   * Create an EventBridge archive to send events to.
   * When you create an archive, incoming events might not immediately start being sent to the archive.
   * Allow a short period of time for changes to take effect.
   *
   * @param props Properties of the archive
   */
  archive(id: string, props: BaseArchiveProps): Archive;

  /**
   * Grants an IAM Principal to send custom events to the eventBus
   * so that they can be matched to rules.
   *
   * @param grantee The principal (no-op if undefined)
   */
  grantPutEventsTo(grantee: iam.IGrantable): iam.Grant;
}

/**
 * Properties to define an event bus
 */
export interface EventBusProps {
  /**
   * The name of the event bus you are creating
   * Note: If 'eventSourceName' is passed in, you cannot set this
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
   * @default - automatically generated name
   */
  readonly eventBusName?: string;

  /**
   * The partner event source to associate with this event bus resource
   * Note: If 'eventBusName' is passed in, you cannot set this
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
   * @default - no partner event source
   */
  readonly eventSourceName?: string;

  /**
   * Dead-letter queue for the event bus
   *
   * @see https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-event-delivery.html#eb-rule-dlq
   *
   * @default - no dead-letter queue
   */
  readonly deadLetterQueue?: sqs.IQueue;

  /**
   * The event bus description.
   *
   * The description can be up to 512 characters long.
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-description
   *
   * @default - no description
   */
  readonly description?: string;

  /**
  * The customer managed key that encrypt events on this event bus.
  *
  * @default - Use an AWS managed key
  */
  readonly kmsKey?: kms.IKey;
}

/**
 * Interface with properties necessary to import a reusable EventBus
 */
export interface EventBusAttributes {
  /**
   * The physical ID of this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
   */
  readonly eventBusName: string;

  /**
   * The ARN of this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Arn-fn::getatt
   */
  readonly eventBusArn: string;

  /**
   * The JSON policy of this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Policy-fn::getatt
   */
  readonly eventBusPolicy: string;

  /**
   * The partner event source to associate with this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
   * @default - no partner event source
   */
  readonly eventSourceName?: string;
}

abstract class EventBusBase extends Resource implements IEventBus {
  /**
   * The physical ID of this event bus resource
   */
  public abstract readonly eventBusName: string;

  /**
   * The ARN of the event bus, such as:
   * arn:aws:events:us-east-2:123456789012:event-bus/aws.partner/PartnerName/acct1/repo1.
   */
  public abstract readonly eventBusArn: string;

  /**
   * The policy for the event bus in JSON form.
   */
  public abstract readonly eventBusPolicy: string;

  /**
   * The name of the partner event source
   */
  public abstract readonly eventSourceName?: string;

  public archive(id: string, props: BaseArchiveProps): Archive {
    return new Archive(this, id, {
      sourceEventBus: this,
      description: props.description || `Event Archive for ${this.eventBusName} Event Bus`,
      eventPattern: props.eventPattern,
      retention: props.retention,
      archiveName: props.archiveName,
    });
  }

  public grantPutEventsTo(grantee: iam.IGrantable): iam.Grant {
    return iam.Grant.addToPrincipal({
      grantee,
      actions: ['events:PutEvents'],
      resourceArns: [this.eventBusArn],
    });
  }
}

/**
 * Define an EventBridge EventBus
 *
 * @resource AWS::Events::EventBus
 */
export class EventBus extends EventBusBase {

  /**
   * Import an existing event bus resource
   * @param scope Parent construct
   * @param id Construct ID
   * @param eventBusArn ARN of imported event bus
   */
  public static fromEventBusArn(scope: Construct, id: string, eventBusArn: string): IEventBus {
    const parts = Stack.of(scope).splitArn(eventBusArn, ArnFormat.SLASH_RESOURCE_NAME);

    return new ImportedEventBus(scope, id, {
      eventBusArn: eventBusArn,
      eventBusName: parts.resourceName || '',
      eventBusPolicy: '',
    });
  }

  /**
   * Import an existing event bus resource
   * @param scope Parent construct
   * @param id Construct ID
   * @param eventBusName Name of imported event bus
   */
  public static fromEventBusName(scope: Construct, id: string, eventBusName: string): IEventBus {
    const eventBusArn = Stack.of(scope).formatArn({
      resource: 'event-bus',
      service: 'events',
      resourceName: eventBusName,
    });

    return EventBus.fromEventBusAttributes(scope, id, {
      eventBusName: eventBusName,
      eventBusArn: eventBusArn,
      eventBusPolicy: '',
    });
  }

  /**
   * Import an existing event bus resource
   * @param scope Parent construct
   * @param id Construct ID
   * @param attrs Imported event bus properties
   */
  public static fromEventBusAttributes(scope: Construct, id: string, attrs: EventBusAttributes): IEventBus {
    return new ImportedEventBus(scope, id, attrs);
  }

  /**
   * Permits an IAM Principal to send custom events to EventBridge
   * so that they can be matched to rules.
   *
   * @param grantee The principal (no-op if undefined)
   * @deprecated use grantAllPutEvents instead
   */
  public static grantPutEvents(grantee: iam.IGrantable): iam.Grant {
    // It's currently not possible to restrict PutEvents to specific resources.
    // See https://docs.aws.amazon.com/eventbridge/latest/userguide/permissions-reference-eventbridge.html
    return iam.Grant.addToPrincipal({
      grantee,
      actions: ['events:PutEvents'],
      resourceArns: ['*'],
    });
  }

  /**
   * Permits an IAM Principal to send custom events to EventBridge
   * so that they can be matched to rules.
   *
   * @param grantee The principal (no-op if undefined)
   */
  public static grantAllPutEvents(grantee: iam.IGrantable): iam.Grant {
    return iam.Grant.addToPrincipal({
      grantee,
      actions: ['events:PutEvents'],
      resourceArns: ['*'],
    });
  }

  private static eventBusProps(defaultEventBusName: string, props: EventBusProps = {}) {
    const { eventBusName, eventSourceName } = props;
    const eventBusNameRegex = /^[\/\.\-_A-Za-z0-9]{1,256}$/;

    if (eventBusName !== undefined && eventSourceName !== undefined) {
      throw new Error(
        '\'eventBusName\' and \'eventSourceName\' cannot both be provided',
      );
    }

    if (eventBusName !== undefined) {
      if (!Token.isUnresolved(eventBusName)) {
        if (eventBusName === 'default') {
          throw new Error(
            '\'eventBusName\' must not be \'default\'',
          );
        } else if (eventBusName.indexOf('/') > -1) {
          throw new Error(
            '\'eventBusName\' must not contain \'/\'',
          );
        } else if (!eventBusNameRegex.test(eventBusName)) {
          throw new Error(
            `'eventBusName' must satisfy: ${eventBusNameRegex}`,
          );
        }
      }
      return { eventBusName };
    }

    if (eventSourceName !== undefined) {
      if (!Token.isUnresolved(eventSourceName)) {
        // Ex: aws.partner/PartnerName/acct1/repo1
        const eventSourceNameRegex = /^aws\.partner(\/[\.\-_A-Za-z0-9]+){2,}$/;
        if (!eventSourceNameRegex.test(eventSourceName)) {
          throw new Error(
            `'eventSourceName' must satisfy: ${eventSourceNameRegex}`,
          );
        } else if (!eventBusNameRegex.test(eventSourceName)) {
          throw new Error(
            `'eventSourceName' must satisfy: ${eventBusNameRegex}`,
          );
        }
      }
      return { eventBusName: eventSourceName, eventSourceName };
    }

    return { eventBusName: defaultEventBusName };
  }

  /**
   * The physical ID of this event bus resource
   */
  public readonly eventBusName: string;

  /**
   * The ARN of the event bus, such as:
   * arn:aws:events:us-east-2:123456789012:event-bus/aws.partner/PartnerName/acct1/repo1.
   */
  public readonly eventBusArn: string;

  /**
   * The policy for the event bus in JSON form.
   */
  public readonly eventBusPolicy: string;

  /**
   * The name of the partner event source
   */
  public readonly eventSourceName?: string;

  constructor(scope: Construct, id: string, props?: EventBusProps) {
    const { eventBusName, eventSourceName } = EventBus.eventBusProps(
      Lazy.string({ produce: () => Names.uniqueId(this) }),
      props,
    );

    super(scope, id, { physicalName: eventBusName });

    if (props?.description && !Token.isUnresolved(props.description) && props.description.length > 512) {
      throw new Error(`description must be less than or equal to 512 characters, got ${props.description.length}`);
    }

    const eventBus = new CfnEventBus(this, 'Resource', {
      name: this.physicalName,
      eventSourceName,
      deadLetterConfig: props?.deadLetterQueue ? {
        arn: props.deadLetterQueue.queueArn,
      } : undefined,
      description: props?.description,
      kmsKeyIdentifier: props?.kmsKey?.keyArn,
    });

    this.eventBusArn = this.getResourceArnAttribute(eventBus.attrArn, {
      service: 'events',
      resource: 'event-bus',
      resourceName: eventBus.name,
    });

    /**
     * Allow EventBridge to use customer managed key
     *
     * @see https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-encryption-key-policy.html#eb-encryption-key-policy-bus
     */
    if (props?.kmsKey) {
      props?.kmsKey.addToResourcePolicy(new iam.PolicyStatement({
        resources: ['*'],
        actions: ['kms:Decrypt', 'kms:GenerateDataKey', 'kms:DescribeKey'],
        principals: [new iam.ServicePrincipal('events.amazonaws.com')],
        conditions: {
          StringEquals: {
            'aws:SourceAccount': this.stack.account,
            'aws:SourceArn': Stack.of(this).formatArn({
              service: 'events',
              resource: 'event-bus',
              resourceName: eventBusName,
            }),
            'kms:EncryptionContext:aws:events:event-bus:arn': Stack.of(this).formatArn({
              service: 'events',
              resource: 'event-bus',
              resourceName: eventBusName,
            }),
          },
        },
      }));
    }

    this.eventBusName = this.getResourceNameAttribute(eventBus.ref);
    this.eventBusPolicy = eventBus.attrPolicy;
    this.eventSourceName = eventBus.eventSourceName;
  }

  /**
   * Adds a statement to the IAM resource policy associated with this event bus.
   */
  public addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {
    if (statement.sid == null) {
      throw new Error('Event Bus policy statements must have a sid');
    }

    // In order to generate new statementIDs for the change in https://github.com/aws/aws-cdk/pull/27340
    const statementId = `cdk-${statement.sid}`.slice(0, 64);
    statement.sid = statementId;
    const policy = new EventBusPolicy(this, statementId, {
      eventBus: this,
      statement: statement.toJSON(),
      statementId,
    });

    return { statementAdded: true, policyDependable: policy };
  }
}

class ImportedEventBus extends EventBusBase {
  public readonly eventBusArn: string;
  public readonly eventBusName: string;
  public readonly eventBusPolicy: string;
  public readonly eventSourceName?: string;

  constructor(scope: Construct, id: string, attrs: EventBusAttributes) {
    const arnParts = Stack.of(scope).splitArn(attrs.eventBusArn, ArnFormat.SLASH_RESOURCE_NAME);
    super(scope, id, {
      account: arnParts.account,
      region: arnParts.region,
    });

    this.eventBusArn = attrs.eventBusArn;
    this.eventBusName = attrs.eventBusName;
    this.eventBusPolicy = attrs.eventBusPolicy;
    this.eventSourceName = attrs.eventSourceName;
  }
}

/**
 * Properties to associate Event Buses with a policy
 */
export interface EventBusPolicyProps {
  /**
   * The event bus to which the policy applies
   */
  readonly eventBus: IEventBus;

  /**
   * An IAM Policy Statement to apply to the Event Bus
   */
  readonly statement: iam.PolicyStatement;

  /**
   * An identifier string for the external account that
   * you are granting permissions to.
   */
  readonly statementId: string;
}

/**
 * The policy for an Event Bus
 *
 * Policies define the operations that are allowed on this resource.
 *
 * You almost never need to define this construct directly.
 *
 * All AWS resources that support resource policies have a method called
 * `addToResourcePolicy()`, which will automatically create a new resource
 * policy if one doesn't exist yet, otherwise it will add to the existing
 * policy.
 *
 * Prefer to use `addToResourcePolicy()` instead.
 */
export class EventBusPolicy extends Resource {
  constructor(scope: Construct, id: string, props: EventBusPolicyProps) {
    super(scope, id);

    new CfnEventBusPolicy(this, 'Resource', {
      statementId: props.statementId!,
      statement: props.statement,
      eventBusName: props.eventBus.eventBusName,
    });
  }
}

```

**CDKTF Type Declarations:**:
Strictly adhere to the following type declarations for relevant CDKTF Resources:
```typescript
// cloudwatch-event-bus
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface CloudwatchEventBusConfig extends cdktf.TerraformMetaArguments {
    /** (Optional) Event bus description. */
    readonly description?: string;
    /** (Optional) Partner event source that the new event bus will be matched with. Must match `name`. */
    readonly eventSourceName?: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus#id CloudwatchEventBus#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /** (Optional) Identifier of the AWS KMS customer managed key for EventBridge to use, if you choose to use a customer managed key to encrypt events on this event bus. The identifier can be the key Amazon Resource Name (ARN), KeyId, key alias, or key alias ARN. */
    readonly kmsKeyIdentifier?: string;
    /** (Required) Name of the new event bus. The names of custom event buses can't contain the / character. To create a partner event bus, ensure that the `name` matches the `eventSourceName`. The following arguments are optional: */
    readonly name: string;
    /** (Optional) Map of tags assigned to the resource. If configured with a provider [`defaultTags` configuration block](/docs/providers/aws/index.html#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level. */
    readonly tags?: {
        [key: string]: string;
    };
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus#tags_all CloudwatchEventBus#tags_all}
    */
    readonly tagsAll?: {
        [key: string]: string;
    };
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus aws_cloudwatch_event_bus}
*/
export declare class CloudwatchEventBus extends cdktf.TerraformResource {
    static readonly tfResourceType = "aws_cloudwatch_event_bus";
    /**
    * Generates CDKTF code for importing a CloudwatchEventBus resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the CloudwatchEventBus to import
    * @param importFromId The id of the existing CloudwatchEventBus that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the CloudwatchEventBus to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus aws_cloudwatch_event_bus} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options CloudwatchEventBusConfig
    */
    constructor(scope: Construct, id: string, config: CloudwatchEventBusConfig);
    get arn(): string;
    private _description?;
    get description(): string;
    set description(value: string);
    resetDescription(): void;
    get descriptionInput(): string | undefined;
    private _eventSourceName?;
    get eventSourceName(): string;
    set eventSourceName(value: string);
    resetEventSourceName(): void;
    get eventSourceNameInput(): string | undefined;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    private _kmsKeyIdentifier?;
    get kmsKeyIdentifier(): string;
    set kmsKeyIdentifier(value: string);
    resetKmsKeyIdentifier(): void;
    get kmsKeyIdentifierInput(): string | undefined;
    private _name?;
    get name(): string;
    set name(value: string);
    get nameInput(): string | undefined;
    private _tags?;
    get tags(): {
        [key: string]: string;
    };
    set tags(value: {
        [key: string]: string;
    });
    resetTags(): void;
    get tagsInput(): {
        [key: string]: string;
    } | undefined;
    private _tagsAll?;
    get tagsAll(): {
        [key: string]: string;
    };
    set tagsAll(value: {
        [key: string]: string;
    });
    resetTagsAll(): void;
    get tagsAllInput(): {
        [key: string]: string;
    } | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}


// cloudwatch-event-bus-policy
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface CloudwatchEventBusPolicyConfig extends cdktf.TerraformMetaArguments {
    /** (Optional) The name of the event bus to set the permissions on. If you omit this, the permissions are set on the `default` event bus. */
    readonly eventBusName?: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus_policy#id CloudwatchEventBusPolicy#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /** (Required) The text of the policy. For more information about building AWS IAM policy documents with Terraform, see the [AWS IAM Policy Document Guide](https://learn.hashicorp.com/terraform/aws/iam-policy). */
    readonly policy: string;
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus_policy aws_cloudwatch_event_bus_policy}
*/
export declare class CloudwatchEventBusPolicy extends cdktf.TerraformResource {
    static readonly tfResourceType = "aws_cloudwatch_event_bus_policy";
    /**
    * Generates CDKTF code for importing a CloudwatchEventBusPolicy resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the CloudwatchEventBusPolicy to import
    * @param importFromId The id of the existing CloudwatchEventBusPolicy that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus_policy#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the CloudwatchEventBusPolicy to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_bus_policy aws_cloudwatch_event_bus_policy} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options CloudwatchEventBusPolicyConfig
    */
    constructor(scope: Construct, id: string, config: CloudwatchEventBusPolicyConfig);
    private _eventBusName?;
    get eventBusName(): string;
    set eventBusName(value: string);
    resetEventBusName(): void;
    get eventBusNameInput(): string | undefined;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    private _policy?;
    get policy(): string;
    set policy(value: string);
    get policyInput(): string | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}


// cloudwatch-event-permission
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface CloudwatchEventPermissionConfig extends cdktf.TerraformMetaArguments {
    /** (Optional) The action that you are enabling the other account to perform. Defaults to `events:PutEvents`. */
    readonly action?: string;
    /** (Optional) The name of the event bus to set the permissions on. If you omit this, the permissions are set on the `default` event bus. */
    readonly eventBusName?: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_permission#id CloudwatchEventPermission#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /** (Required) The 12-digit AWS account ID that you are permitting to put events to your default event bus. Specify `*` to permit any account to put events to your default event bus, optionally limited by `condition`. */
    readonly principal: string;
    /** (Required) An identifier string for the external account that you are granting permissions to. */
    readonly statementId: string;
    /** (Optional) Configuration block to limit the event bus permissions you are granting to only accounts that fulfill the condition. Specified below. */
    readonly condition?: CloudwatchEventPermissionCondition;
}
export interface CloudwatchEventPermissionCondition {
    /** (Required) Key for the condition. Valid values: `aws:PrincipalOrgID`. */
    readonly key: string;
    /** (Required) Type of condition. Value values: `StringEquals`. */
    readonly type: string;
    /** (Required) Value for the key. */
    readonly value: string;
}
export declare function cloudwatchEventPermissionConditionToTerraform(struct?: CloudwatchEventPermissionConditionOutputReference | CloudwatchEventPermissionCondition): any;
export declare function cloudwatchEventPermissionConditionToHclTerraform(struct?: CloudwatchEventPermissionConditionOutputReference | CloudwatchEventPermissionCondition): any;
export declare class CloudwatchEventPermissionConditionOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): CloudwatchEventPermissionCondition | undefined;
    set internalValue(value: CloudwatchEventPermissionCondition | undefined);
    private _key?;
    get key(): string;
    set key(value: string);
    get keyInput(): string | undefined;
    private _type?;
    get type(): string;
    set type(value: string);
    get typeInput(): string | undefined;
    private _value?;
    get value(): string;
    set value(value: string);
    get valueInput(): string | undefined;
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_permission aws_cloudwatch_event_permission}
*/
export declare class CloudwatchEventPermission extends cdktf.TerraformResource {
    static readonly tfResourceType = "aws_cloudwatch_event_permission";
    /**
    * Generates CDKTF code for importing a CloudwatchEventPermission resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the CloudwatchEventPermission to import
    * @param importFromId The id of the existing CloudwatchEventPermission that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_permission#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the CloudwatchEventPermission to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/cloudwatch_event_permission aws_cloudwatch_event_permission} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options CloudwatchEventPermissionConfig
    */
    constructor(scope: Construct, id: string, config: CloudwatchEventPermissionConfig);
    private _action?;
    get action(): string;
    set action(value: string);
    resetAction(): void;
    get actionInput(): string | undefined;
    private _eventBusName?;
    get eventBusName(): string;
    set eventBusName(value: string);
    resetEventBusName(): void;
    get eventBusNameInput(): string | undefined;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    private _principal?;
    get principal(): string;
    set principal(value: string);
    get principalInput(): string | undefined;
    private _statementId?;
    get statementId(): string;
    set statementId(value: string);
    get statementIdInput(): string | undefined;
    private _condition;
    get condition(): CloudwatchEventPermissionConditionOutputReference;
    putCondition(value: CloudwatchEventPermissionCondition): void;
    resetCondition(): void;
    get conditionInput(): CloudwatchEventPermissionCondition | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}

```

**AWS CDK Type Declarations:**
Refer to the following Reference declarations used by the AWSCDK constructs:
```typescript
// events.generated.d.ts
import * as cdk from "../../core";
import * as constructs from "constructs";
import * as cfn_parse from "../../core/lib/helpers-internal";
;
;
;
;
;
;
;
;
;
;
/**
 * Specifies an event bus within your account.
 *
 * This can be a custom event bus which you can use to receive events from your custom applications and services, or it can be a partner event bus which can be matched to a partner event source.
 *
 * > As an aid to help you jumpstart developing CloudFormation templates, the EventBridge console enables you to create templates from the existing event buses in your account. For more information, see [Generating CloudFormation templates from an EventBridge event bus](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-generate-event-bus-template.html) in the *Amazon EventBridge User Guide* .
 *
 * @cloudformationResource AWS::Events::EventBus
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html
 */
export declare class CfnEventBus extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggableV2 {
    /**
     * The CloudFormation resource type name for this resource class.
     */
    static readonly CFN_RESOURCE_TYPE_NAME: string;
    /**
     * Build a CfnEventBus from CloudFormation properties
     *
     * A factory method that creates a new instance of this class from an object
     * containing the CloudFormation properties of this resource.
     * Used in the @aws-cdk/cloudformation-include module.
     *
     * @internal
     */
    static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEventBus;
    /**
     * The ARN of the event bus, such as `arn:aws:events:us-east-2:123456789012:event-bus/aws.partner/PartnerName/acct1/repo1` .
     *
     * @cloudformationAttribute Arn
     */
    readonly attrArn: string;
    /**
     * The name of the event bus, such as `PartnerName/acct1/repo1` .
     *
     * @cloudformationAttribute Name
     */
    readonly attrName: string;
    /**
     * @cloudformationAttribute Policy
     */
    readonly attrPolicy: string;
    /**
     * Tag Manager which manages the tags for this resource
     */
    readonly cdkTagManager: cdk.TagManager;
    /**
     * Configuration details of the Amazon SQS queue for EventBridge to use as a dead-letter queue (DLQ).
     */
    deadLetterConfig?: CfnEventBus.DeadLetterConfigProperty | cdk.IResolvable;
    /**
     * The event bus description.
     */
    description?: string;
    /**
     * If you are creating a partner event bus, this specifies the partner event source that the new event bus will be matched with.
     */
    eventSourceName?: string;
    /**
     * The identifier of the AWS KMS customer managed key for EventBridge to use, if you choose to use a customer managed key to encrypt events on this event bus.
     */
    kmsKeyIdentifier?: string;
    /**
     * The name of the new event bus.
     */
    name: string;
    /**
     * The permissions policy of the event bus, describing which other AWS accounts can write events to this event bus.
     */
    policy?: any | cdk.IResolvable | string;
    /**
     * Tags to associate with the event bus.
     */
    tags?: Array<cdk.CfnTag>;
    /**
     * @param scope Scope in which this resource is defined
     * @param id Construct identifier for this resource (unique in its scope)
     * @param props Resource properties
     */
    constructor(scope: constructs.Construct, id: string, props: CfnEventBusProps);
    protected get cfnProperties(): Record<string, any>;
    /**
     * Examines the CloudFormation resource and discloses attributes
     *
     * @param inspector tree inspector to collect and process attributes
     */
    inspect(inspector: cdk.TreeInspector): void;
    protected renderProperties(props: Record<string, any>): Record<string, any>;
}
export declare namespace CfnEventBus {
    /**
     * Configuration details of the Amazon SQS queue for EventBridge to use as a dead-letter queue (DLQ).
     *
     * For more information, see [Using dead-letter queues to process undelivered events](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-event-delivery.html#eb-rule-dlq) in the *EventBridge User Guide* .
     *
     * @struct
     * @stability external
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-eventbus-deadletterconfig.html
     */
    interface DeadLetterConfigProperty {
        /**
         * The ARN of the SQS queue specified as the target for the dead-letter queue.
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-eventbus-deadletterconfig.html#cfn-events-eventbus-deadletterconfig-arn
         */
        readonly arn?: string;
    }
}
/**
 * Properties for defining a `CfnEventBus`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html
 */
export interface CfnEventBusProps {
    /**
     * Configuration details of the Amazon SQS queue for EventBridge to use as a dead-letter queue (DLQ).
     *
     * For more information, see [Using dead-letter queues to process undelivered events](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-event-delivery.html#eb-rule-dlq) in the *EventBridge User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-deadletterconfig
     */
    readonly deadLetterConfig?: CfnEventBus.DeadLetterConfigProperty | cdk.IResolvable;
    /**
     * The event bus description.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-description
     */
    readonly description?: string;
    /**
     * If you are creating a partner event bus, this specifies the partner event source that the new event bus will be matched with.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
     */
    readonly eventSourceName?: string;
    /**
     * The identifier of the AWS KMS customer managed key for EventBridge to use, if you choose to use a customer managed key to encrypt events on this event bus.
     *
     * The identifier can be the key Amazon Resource Name (ARN), KeyId, key alias, or key alias ARN.
     *
     * If you do not specify a customer managed key identifier, EventBridge uses an AWS owned key to encrypt events on the event bus.
     *
     * For more information, see [Managing keys](https://docs.aws.amazon.com/kms/latest/developerguide/getting-started.html) in the *AWS Key Management Service Developer Guide* .
     *
     * > Archives and schema discovery are not supported for event buses encrypted using a customer managed key. EventBridge returns an error if:
     * >
     * > - You call `[CreateArchive](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_CreateArchive.html)` on an event bus set to use a customer managed key for encryption.
     * > - You call `[CreateDiscoverer](https://docs.aws.amazon.com/eventbridge/latest/schema-reference/v1-discoverers.html#CreateDiscoverer)` on an event bus set to use a customer managed key for encryption.
     * > - You call `[UpdatedEventBus](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_UpdatedEventBus.html)` to set a customer managed key on an event bus with an archives or schema discovery enabled.
     * >
     * > To enable archives or schema discovery on an event bus, choose to use an AWS owned key . For more information, see [Data encryption in EventBridge](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-encryption.html) in the *Amazon EventBridge User Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-kmskeyidentifier
     */
    readonly kmsKeyIdentifier?: string;
    /**
     * The name of the new event bus.
     *
     * Custom event bus names can't contain the `/` character, but you can use the `/` character in partner event bus names. In addition, for partner event buses, the name must exactly match the name of the partner event source that this event bus is matched to.
     *
     * You can't use the name `default` for a custom event bus, as this name is already used for your account's default event bus.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
     */
    readonly name: string;
    /**
     * The permissions policy of the event bus, describing which other AWS accounts can write events to this event bus.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-policy
     */
    readonly policy?: any | cdk.IResolvable | string;
    /**
     * Tags to associate with the event bus.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
}
/**
 * Running `PutPermission` permits the specified AWS account or AWS organization to put events to the specified *event bus* .
 *
 * Amazon EventBridge rules in your account are triggered by these events arriving to an event bus in your account.
 *
 * For another account to send events to your account, that external account must have an EventBridge rule with your account's event bus as a target.
 *
 * To enable multiple AWS accounts to put events to your event bus, run `PutPermission` once for each of these accounts. Or, if all the accounts are members of the same AWS organization, you can run `PutPermission` once specifying `Principal` as "*" and specifying the AWS organization ID in `Condition` , to grant permissions to all accounts in that organization.
 *
 * If you grant permissions using an organization, then accounts in that organization must specify a `RoleArn` with proper permissions when they use `PutTarget` to add your account's event bus as a target. For more information, see [Sending and Receiving Events Between AWS Accounts](https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html) in the *Amazon EventBridge User Guide* .
 *
 * The permission policy on the event bus cannot exceed 10 KB in size.
 *
 * @cloudformationResource AWS::Events::EventBusPolicy
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html
 */
export declare class CfnEventBusPolicy extends cdk.CfnResource implements cdk.IInspectable {
    /**
     * The CloudFormation resource type name for this resource class.
     */
    static readonly CFN_RESOURCE_TYPE_NAME: string;
    /**
     * Build a CfnEventBusPolicy from CloudFormation properties
     *
     * A factory method that creates a new instance of this class from an object
     * containing the CloudFormation properties of this resource.
     * Used in the @aws-cdk/cloudformation-include module.
     *
     * @internal
     */
    static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnEventBusPolicy;
    /**
     * @cloudformationAttribute Id
     */
    readonly attrId: string;
    /**
     * The action that you are enabling the other account to perform.
     */
    action?: string;
    /**
     * This parameter enables you to limit the permission to accounts that fulfill a certain condition, such as being a member of a certain AWS organization.
     */
    condition?: CfnEventBusPolicy.ConditionProperty | cdk.IResolvable;
    /**
     * The name of the event bus associated with the rule.
     */
    eventBusName?: string;
    /**
     * The 12-digit AWS account ID that you are permitting to put events to your default event bus.
     */
    principal?: string;
    /**
     * A JSON string that describes the permission policy statement.
     */
    statement?: any | cdk.IResolvable;
    /**
     * An identifier string for the external account that you are granting permissions to.
     */
    statementId: string;
    /**
     * @param scope Scope in which this resource is defined
     * @param id Construct identifier for this resource (unique in its scope)
     * @param props Resource properties
     */
    constructor(scope: constructs.Construct, id: string, props: CfnEventBusPolicyProps);
    protected get cfnProperties(): Record<string, any>;
    /**
     * Examines the CloudFormation resource and discloses attributes
     *
     * @param inspector tree inspector to collect and process attributes
     */
    inspect(inspector: cdk.TreeInspector): void;
    protected renderProperties(props: Record<string, any>): Record<string, any>;
}
export declare namespace CfnEventBusPolicy {
    /**
     * A JSON string which you can use to limit the event bus permissions you are granting to only accounts that fulfill the condition.
     *
     * Currently, the only supported condition is membership in a certain AWS organization. The string must contain `Type` , `Key` , and `Value` fields. The `Value` field specifies the ID of the AWS organization. Following is an example value for `Condition` :
     *
     * `'{"Type" : "StringEquals", "Key": "aws:PrincipalOrgID", "Value": "o-1234567890"}'`
     *
     * @struct
     * @stability external
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-eventbuspolicy-condition.html
     */
    interface ConditionProperty {
        /**
         * Specifies the key for the condition.
         *
         * Currently the only supported key is `aws:PrincipalOrgID` .
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-eventbuspolicy-condition.html#cfn-events-eventbuspolicy-condition-key
         */
        readonly key?: string;
        /**
         * Specifies the type of condition.
         *
         * Currently the only supported value is `StringEquals` .
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-eventbuspolicy-condition.html#cfn-events-eventbuspolicy-condition-type
         */
        readonly type?: string;
        /**
         * Specifies the value for the key.
         *
         * Currently, this must be the ID of the organization.
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-events-eventbuspolicy-condition.html#cfn-events-eventbuspolicy-condition-value
         */
        readonly value?: string;
    }
}
/**
 * Properties for defining a `CfnEventBusPolicy`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html
 */
export interface CfnEventBusPolicyProps {
    /**
     * The action that you are enabling the other account to perform.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html#cfn-events-eventbuspolicy-action
     */
    readonly action?: string;
    /**
     * This parameter enables you to limit the permission to accounts that fulfill a certain condition, such as being a member of a certain AWS organization.
     *
     * For more information about AWS Organizations, see [What Is AWS Organizations](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html) in the *AWS Organizations User Guide* .
     *
     * If you specify `Condition` with an AWS organization ID, and specify "*" as the value for `Principal` , you grant permission to all the accounts in the named organization.
     *
     * The `Condition` is a JSON string which must contain `Type` , `Key` , and `Value` fields.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html#cfn-events-eventbuspolicy-condition
     */
    readonly condition?: CfnEventBusPolicy.ConditionProperty | cdk.IResolvable;
    /**
     * The name of the event bus associated with the rule.
     *
     * If you omit this, the default event bus is used.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html#cfn-events-eventbuspolicy-eventbusname
     */
    readonly eventBusName?: string;
    /**
     * The 12-digit AWS account ID that you are permitting to put events to your default event bus.
     *
     * Specify "*" to permit any account to put events to your default event bus.
     *
     * If you specify "*" without specifying `Condition` , avoid creating rules that may match undesirable events. To create more secure rules, make sure that the event pattern for each rule contains an `account` field with a specific account ID from which to receive events. Rules with an account field do not match any events sent from other accounts.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html#cfn-events-eventbuspolicy-principal
     */
    readonly principal?: string;
    /**
     * A JSON string that describes the permission policy statement.
     *
     * You can include a `Policy` parameter in the request instead of using the `StatementId` , `Action` , `Principal` , or `Condition` parameters.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html#cfn-events-eventbuspolicy-statement
     */
    readonly statement?: any | cdk.IResolvable;
    /**
     * An identifier string for the external account that you are granting permissions to.
     *
     * If you later want to revoke the permission for this external account, specify this `StatementId` when you run [RemovePermission](https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_RemovePermission.html) .
     *
     * > Each `StatementId` must be unique.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbuspolicy.html#cfn-events-eventbuspolicy-statementid
     */
    readonly statementId: string;
}
;
;
;

```

**Conversion**:
```typescript
import {
  cloudwatchEventBus,
  cloudwatchEventBusPolicy,
  cloudwatchEventPermission,
} from "@cdktf/provider-aws";
import { Lazy, Token } from "cdktf";
import { Construct } from "constructs";
import { Archive, BaseArchiveProps } from "./archive";
import * as encryption from "../encryption";
import * as iam from "../iam";
// import { IQueue } from "./queue";
import { ArnFormat, AwsConstructBase, AwsConstructProps, AwsStack } from "..";

/**
 * Outputs to register with the Grid
 */
export interface EventBusOutputs {
  /**
   * The physical ID of this event bus resource
   */
  readonly name: string;

  /**
   * The ARN of this event bus resource
   */
  readonly arn: string;

  /**
   * The partner event source to associate with this event bus resource
   */
  readonly eventSourceName?: string;
}

/**
 * Interface which all EventBus based classes MUST implement
 */
export interface IEventBus extends iam.IAwsConstructWithPolicy {
  /**
   * The physical ID of this event bus resource
   *
   * @attribute
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
   */
  readonly eventBusName: string;

  /**
   * The ARN of this event bus resource
   *
   * @attribute
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Arn-fn::getatt
   */
  readonly eventBusArn: string;

  /**
   * The partner event source to associate with this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
   */
  readonly eventSourceName?: string;

  /**
   * Create an EventBridge archive to send events to.
   * When you create an archive, incoming events might not immediately start being sent to the archive.
   * Allow a short period of time for changes to take effect.
   *
   * @param props Properties of the archive
   */
  archive(id: string, props: BaseArchiveProps): Archive;

  /**
   * Grants an IAM Principal to send custom events to the eventBus
   * so that they can be matched to rules.
   *
   * @param grantee The principal (no-op if undefined)
   */
  grantPutEventsTo(grantee: iam.IGrantable): iam.Grant;
}

/**
 * Properties to define an event bus
 */
export interface EventBusProps extends AwsConstructProps {
  /**
   * The name of the event bus you are creating
   * Note: If 'eventSourceName' is passed in, you cannot set this
   *
   * NOTE: the names of custom event buses can't contain the '/' character
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
   * @default - automatically generated name
   */
  readonly eventBusName?: string;

  /**
   * The partner event source to associate with this event bus resource
   * Note: If 'eventBusName' is passed in, you cannot set this
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
   * @default - no partner event source
   */
  readonly eventSourceName?: string;

  // // TODO: Dead-letter queue is not supported by terraform-provider-aws
  // /**
  //  * Dead-letter queue for the event bus
  //  *
  //  * @see https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-event-delivery.html#eb-rule-dlq
  //  *
  //  * @default - no dead-letter queue
  //  */
  // readonly deadLetterQueue?: IQueue;

  /**
   * The customer managed key that encrypt events on this event bus.
   *
   * @default - Use an AWS managed key
   */
  readonly kmsKey?: encryption.IKey;

  // // TODO: Description is not supported by terraform-provider-aws
  // /**
  //  * The event bus description.
  //  *
  //  * The description can be up to 512 characters long.
  //  *
  //  * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-description
  //  *
  //  * @default - no description
  //  */
  // readonly description?: string;
}

/**
 * Interface with properties necessary to import a reusable EventBus
 */
export interface EventBusAttributes {
  /**
   * The physical ID of this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
   */
  readonly eventBusName: string;

  /**
   * The ARN of this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Arn-fn::getatt
   */
  readonly eventBusArn: string;

  /**
   * The partner event source to associate with this event bus resource
   *
   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
   * @default - no partner event source
   */
  readonly eventSourceName?: string;
}

abstract class EventBusBase extends AwsConstructBase implements IEventBus {
  /**
   * The physical ID of this event bus resource
   */
  public abstract readonly eventBusName: string;

  /**
   * The ARN of the event bus, such as:
   * arn:aws:events:us-east-2:123456789012:event-bus/aws.partner/PartnerName/acct1/repo1.
   */
  public abstract readonly eventBusArn: string;

  /**
   * The name of the partner event source
   */
  public abstract readonly eventSourceName?: string;

  public archive(id: string, props: BaseArchiveProps): Archive {
    return new Archive(this, id, {
      sourceEventBus: this,
      description:
        props.description || `Event Archive for ${this.eventBusName} Event Bus`,
      eventPattern: props.eventPattern,
      retention: props.retention,
      archiveName: props.archiveName,
    });
  }

  public grantPutEventsTo(grantee: iam.IGrantable): iam.Grant {
    return iam.Grant.addToPrincipal({
      grantee,
      actions: ["events:PutEvents"],
      resourceArns: [this.eventBusArn],
    });
  }

  public abstract addToResourcePolicy(
    statement: iam.PolicyStatement
  ): iam.AddToResourcePolicyResult;
}

/**
 * Define an EventBridge EventBus
 *
 * @resource aws_cloudwatch_event_bus
 */
export class EventBus extends EventBusBase {
  /**
   * Import an existing event bus resource
   * @param scope Parent construct
   * @param id Construct ID
   * @param eventBusArn ARN of imported event bus
   */
  public static fromEventBusArn(
    scope: Construct,
    id: string,
    eventBusArn: string
  ): IEventBus {
    const parts = AwsStack.ofAwsConstruct(scope).splitArn(
      eventBusArn,
      ArnFormat.SLASH_RESOURCE_NAME
    );

    return new ImportedEventBus(scope, id, {
      eventBusArn: eventBusArn,
      eventBusName: parts.resourceName || "",
    });
  }

  /**
   * Import an existing event bus resource
   * @param scope Parent construct
   * @param id Construct ID
   * @param eventBusName Name of imported event bus
   */
  public static fromEventBusName(
    scope: Construct,
    id: string,
    eventBusName: string
  ): IEventBus {
    const eventBusArn = AwsStack.ofAwsConstruct(scope).formatArn({
      resource: "event-bus",
      service: "events",
      resourceName: eventBusName,
    });

    return EventBus.fromEventBusAttributes(scope, id, {
      eventBusName: eventBusName,
      eventBusArn: eventBusArn,
    });
  }

  /**
   * Import an existing event bus resource
   * @param scope Parent construct
   * @param id Construct ID
   * @param attrs Imported event bus properties
   */
  public static fromEventBusAttributes(
    scope: Construct,
    id: string,
    attrs: EventBusAttributes
  ): IEventBus {
    return new ImportedEventBus(scope, id, attrs);
  }

  /**
   * Permits an IAM Principal to send custom events to EventBridge
   * so that they can be matched to rules.
   *
   * @param grantee The principal (no-op if undefined)
   * @deprecated use grantAllPutEvents instead
   */
  public static grantPutEvents(grantee: iam.IGrantable): iam.Grant {
    // It's currently not possible to restrict PutEvents to specific resources.
    // See https://docs.aws.amazon.com/eventbridge/latest/userguide/permissions-reference-eventbridge.html
    return iam.Grant.addToPrincipal({
      grantee,
      actions: ["events:PutEvents"],
      resourceArns: ["*"],
    });
  }

  /**
   * Permits an IAM Principal to send custom events to EventBridge
   * so that they can be matched to rules.
   *
   * @param grantee The principal (no-op if undefined)
   */
  public static grantAllPutEvents(grantee: iam.IGrantable): iam.Grant {
    return iam.Grant.addToPrincipal({
      grantee,
      actions: ["events:PutEvents"],
      resourceArns: ["*"],
    });
  }

  private static eventBusProps(
    defaultEventBusName: string,
    props: EventBusProps = {}
  ) {
    const { eventBusName, eventSourceName } = props;
    const eventBusNameRegex = /^[\/\.\-_A-Za-z0-9]{1,256}$/;

    if (eventBusName !== undefined && eventSourceName !== undefined) {
      throw new Error(
        "'eventBusName' and 'eventSourceName' cannot both be provided"
      );
    }

    if (eventBusName !== undefined) {
      if (!Token.isUnresolved(eventBusName)) {
        if (eventBusName === "default") {
          throw new Error("'eventBusName' must not be 'default'");
        } else if (eventBusName.indexOf("/") > -1) {
          throw new Error("'eventBusName' must not contain '/'");
        } else if (!eventBusNameRegex.test(eventBusName)) {
          throw new Error(`'eventBusName' must satisfy: ${eventBusNameRegex}`);
        }
      }
      return { eventBusName };
    }

    if (eventSourceName !== undefined) {
      if (!Token.isUnresolved(eventSourceName)) {
        // Ex: aws.partner/PartnerName/acct1/repo1
        const eventSourceNameRegex = /^aws\.partner(\/[\.\-_A-Za-z0-9]+){2,}$/;
        if (!eventSourceNameRegex.test(eventSourceName)) {
          throw new Error(
            `'eventSourceName' must satisfy: ${eventSourceNameRegex}`
          );
        } else if (!eventBusNameRegex.test(eventSourceName)) {
          throw new Error(
            `'eventSourceName' must satisfy: ${eventBusNameRegex}`
          );
        }
      }
      return { eventBusName: eventSourceName, eventSourceName };
    }

    return { eventBusName: defaultEventBusName };
  }

  public readonly resource: cloudwatchEventBus.CloudwatchEventBus;

  public readonly eventBusOutputs: EventBusOutputs;
  public get outputs(): Record<string, any> {
    return this.eventBusOutputs;
  }

  private policy?: EventBusPolicy;

  /**
   * The physical ID of this event bus resource
   */
  public get eventBusName(): string {
    return this.resource.name;
  }

  /**
   * The ARN of the event bus, such as:
   * arn:aws:events:us-east-2:123456789012:event-bus/aws.partner/PartnerName/acct1/repo1.
   */
  public get eventBusArn(): string {
    return this.resource.arn;
  }

  /**
   * The name of the partner event source
   */
  public readonly eventSourceName?: string;

  constructor(scope: Construct, id: string, props?: EventBusProps) {
    const { eventBusName, eventSourceName } = EventBus.eventBusProps(
      // TODO(vincent): Figure out how this works...
      Lazy.stringValue({ produce: () => AwsStack.uniqueId(this) }),
      props
    );

    super(scope, id, props);

    // if (
    //   props?.description &&
    //   !Token.isUnresolved(props.description) &&
    //   props.description.length > 512
    // ) {
    //   throw new Error(
    //     `description must be less than or equal to 512 characters, got ${props.description.length}`,
    //   );
    // }

    this.resource = new cloudwatchEventBus.CloudwatchEventBus(
      this,
      "Resource",
      {
        name: eventBusName,
        eventSourceName,
        kmsKeyIdentifier: props?.kmsKey?.keyArn,
        // description: props?.description, // Description is not supported by terraform-provider-aws
        // TODO: Missing in terraform-provider-aws
        // ref:
        //  - https://github.com/hashicorp/terraform-provider-aws/issues/41563
        //  - https://github.com/hashicorp/terraform-provider-aws/blob/v5.88.0/internal/service/events/bus.go#L79
        //  - https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_CreateEventBus.html#API_CreateEventBus_RequestSyntax
        // deadletter_config: props?.deadLetterQueue
      }
    );

    /**
     * Allow EventBridge to use customer managed key
     *
     * @see https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-encryption-key-policy.html#eb-encryption-key-policy-bus
     */
    if (props?.kmsKey) {
      props?.kmsKey.addToResourcePolicy(
        new iam.PolicyStatement({
          resources: ["*"],
          actions: ["kms:Decrypt", "kms:GenerateDataKey", "kms:DescribeKey"],
          principals: [new iam.ServicePrincipal("events.amazonaws.com")],
          condition: [
            {
              test: "StringEquals",
              variable: "aws:SourceAccount",
              values: [this.stack.account],
            },
            {
              test: "StringEquals",
              variable: "aws:SourceArn",
              values: [
                AwsStack.ofAwsConstruct(this).formatArn({
                  service: "events",
                  resource: "event-bus",
                  resourceName: eventBusName,
                }),
              ],
            },
            {
              test: "StringEquals",
              variable: "kms:EncryptionContext:aws:events:event-bus:arn",
              values: [
                AwsStack.ofAwsConstruct(this).formatArn({
                  service: "events",
                  resource: "event-bus",
                  resourceName: eventBusName,
                }),
              ],
            },
          ],
        })
      );
    }

    this.eventSourceName = this.resource.eventSourceName;
    this.eventBusOutputs = {
      name: this.eventBusName,
      arn: this.eventBusArn,
      eventSourceName: this.eventSourceName,
    };
  }

  /**
   * Adds a statement to the IAM resource policy associated with this event bus.
   */
  public addToResourcePolicy(
    statement: iam.PolicyStatement
  ): iam.AddToResourcePolicyResult {
    if (!this.policy) {
      this.policy = new EventBusPolicy(this, "Policy", { eventBus: this });
    }

    if (this.policy) {
      this.policy.document.addStatements(statement);
      return { statementAdded: true, policyDependable: this.policy };
    }

    return { statementAdded: false };
  }
}

class ImportedEventBus extends EventBusBase {
  public readonly eventBusArn: string;
  public readonly eventBusName: string;
  public readonly eventSourceName?: string;
  public readonly eventBusOutputs: EventBusOutputs;
  public get outputs() {
    return this.eventBusOutputs;
  }

  constructor(scope: Construct, id: string, attrs: EventBusAttributes) {
    const arnParts = AwsStack.ofAwsConstruct(scope).splitArn(
      attrs.eventBusArn,
      ArnFormat.SLASH_RESOURCE_NAME
    );
    super(scope, id, {
      account: arnParts.account,
      region: arnParts.region,
    });

    this.eventBusArn = attrs.eventBusArn;
    this.eventBusName = attrs.eventBusName;
    this.eventSourceName = attrs.eventSourceName;
    this.eventBusOutputs = {
      name: this.eventBusName,
      arn: this.eventBusArn,
      eventSourceName: this.eventSourceName,
    };
  }

  public addToResourcePolicy(
    _statement: iam.PolicyStatement
  ): iam.AddToResourcePolicyResult {
    throw new Error(
      [
        "Cannot add a statement to an imported EventBus. You may use `EventBridgePermission` instead.",
        "If the EventBus already has a policy attached, the permissions will be overwritten.",
      ].join("\n")
    );
  }
}

/**
 * Properties to associate Event Buses with a policy
 */
export interface EventBusPolicyProps extends AwsConstructProps {
  /**
   * The event bus to which the policy applies
   */
  readonly eventBus: IEventBus;
}

/**
 * The policy for an Event Bus
 *
 * Policies define the operations that are allowed on this resource.
 *
 * You almost never need to define this construct directly.
 *
 * The EventBusPolicy resource (`aws_cloudwatch_event_bus_policy`)
 * is incompatible with the EventBridgePermission resource (`aws_cloudwatch_event_permission`)
 * and will overwrite permissions.
 *
 * All AWS resources that support resource policies have a method called
 * `addToResourcePolicy()`, which will automatically create a new resource
 * policy if one doesn't exist yet, otherwise it will add to the existing
 * policy.
 *
 * Prefer to use `addToResourcePolicy()` instead.
 *
 * @resource aws_cloudwatch_event_bus_policy
 */
export class EventBusPolicy extends AwsConstructBase {
  /**
   * The IAM policy document for this policy.
   */
  public readonly document: iam.PolicyDocument;
  public get outputs(): Record<string, any> {
    return this.document.outputs;
  }
  constructor(scope: Construct, id: string, props: EventBusPolicyProps) {
    super(scope, id, props);
    this.document = new iam.PolicyDocument(this, "Document");

    new cloudwatchEventBusPolicy.CloudwatchEventBusPolicy(this, "Resource", {
      // https://github.com/hashicorp/terraform-provider-aws/pull/16874#discussion_r656024830
      policy: this.document.json,
      eventBusName: props.eventBus.eventBusName,
    });
  }
}

/**
 * Properties to add permissions to an Event Bus
 */
export interface EventBridgePermissionProps extends AwsConstructProps {
  // TODO: Auto generate this using struct builder to keep docs updated?
  /**
   * The event bus to which the policy applies
   */
  readonly eventBus: IEventBus;
  /**
   * An identifier string for the external account that
   * you are granting permissions to.
   *
   * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.68.0/docs/resources/cloudwatch_event_permission#statement_id CloudwatchEventPermission#statement_id}
   */
  readonly statementId: string;
  /**
   * The action that you are enabling the other account to perform. Defaults to events:PutEvents
   *
   * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.68.0/docs/resources/cloudwatch_event_permission#action CloudwatchEventPermission#action}
   * @default "events:PutEvents"
   */
  readonly action?: string;
  /**
   * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.68.0/docs/resources/cloudwatch_event_permission#event_bus_name CloudwatchEventPermission#event_bus_name}
   */
  readonly eventBusName?: string;
  /**
   * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.68.0/docs/resources/cloudwatch_event_permission#id CloudwatchEventPermission#id}
   *
   * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
   * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
   */
  readonly id?: string;
  /**
   * The 12-digit AWS account ID that you are permitting to put events to your default event bus.
   * Specify * to permit any account to put events to your default event bus, optionally limited
   * by condition.
   *
   * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.68.0/docs/resources/cloudwatch_event_permission#principal CloudwatchEventPermission#principal}
   */
  readonly principal: string;
  /**
   * Configuration block to limit the event bus permissions you are granting to only accounts that
   * fulfill the condition.condition block
   *
   * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.68.0/docs/resources/cloudwatch_event_permission#condition CloudwatchEventPermission#condition}
   */
  readonly condition?: cloudwatchEventPermission.CloudwatchEventPermissionCondition;
}

/**
 * A single permission for an Event Bus
 *
 * All AWS resources that support resource policies have a method called
 * `addToResourcePolicy()`, which will automatically create a new resource
 * policy if one doesn't exist yet, otherwise it will add to the existing
 * policy.
 *
 * If `addToResourcePolicy()` was used on the event bus, The EventBusPolicy resource
 * (`aws_cloudwatch_event_bus_policy`) is incompatible with this resource and
 * will overwrite permissions.
 *
 * @resource aws_cloudwatch_event_permission
 */
export class EventBridgePermission extends AwsConstructBase {
  public get outputs(): Record<string, any> {
    return {};
  }
  constructor(scope: Construct, id: string, props: EventBridgePermissionProps) {
    super(scope, id, props);

    new cloudwatchEventPermission.CloudwatchEventPermission(this, "Resource", {
      // https://github.com/hashicorp/terraform-provider-aws/pull/16874#discussion_r656024830
      ...props,
      eventBusName: props.eventBus.eventBusName,
    });
  }
}

```

## Notes

- Ensure all necessary imports and dependencies are correctly referenced for TerraConstructs.
- Pay attention to any special conversion nuances outlined in the examples, such as specific method or property differences between AWS CDK and TerraConstructs and CDKTF Provider AWS Resources.
- Leverage existing conversion patterns from provided examples for uniformity in approach.

## Simulated User Prompt
Convert the following AWS CDK Constructs to TerraConstructs.
```typescript
import { Construct } from 'constructs';
import { KinesisMetrics } from './kinesis-fixed-canned-metrics';
import { CfnStream } from './kinesis.generated';
import { ResourcePolicy } from './resource-policy';
import * as cloudwatch from '../../aws-cloudwatch';
import * as iam from '../../aws-iam';
import * as kms from '../../aws-kms';
import { ArnFormat, Aws, CfnCondition, Duration, Fn, IResolvable, IResource, RemovalPolicy, Resource, ResourceProps, Stack, Token } from '../../core';

const READ_OPERATIONS = [
  'kinesis:DescribeStreamSummary',
  'kinesis:GetRecords',
  'kinesis:GetShardIterator',
  'kinesis:ListShards',
  'kinesis:SubscribeToShard',
  'kinesis:DescribeStream',
  'kinesis:ListStreams',
  'kinesis:DescribeStreamConsumer',
];

const WRITE_OPERATIONS = [
  'kinesis:ListShards',
  'kinesis:PutRecord',
  'kinesis:PutRecords',
];

/**
 * A Kinesis Stream
 */
export interface IStream extends IResource {
  /**
   * The ARN of the stream.
   *
   * @attribute
   */
  readonly streamArn: string;

  /**
   * The name of the stream
   *
   * @attribute
   */
  readonly streamName: string;

  /**
   * Optional KMS encryption key associated with this stream.
   */
  readonly encryptionKey?: kms.IKey;

  /**
   * Adds a statement to the IAM resource policy associated with this stream.
   *
   * If this stream was created in this stack (`new Stream`), a resource policy
   * will be automatically created upon the first call to `addToResourcePolicy`. If
   * the stream is imported (`Stream.import`), then this is a no-op.
   */
  addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;

  /**
   * Grant read permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to ues the key to decrypt the
   * contents of the stream will also be granted.
   */
  grantRead(grantee: iam.IGrantable): iam.Grant;

  /**
   * Grant write permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to ues the key to encrypt the
   * contents of the stream will also be granted.
   */
  grantWrite(grantee: iam.IGrantable): iam.Grant;

  /**
   * Grants read/write permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to use the key for
   * encrypt/decrypt will also be granted.
   */
  grantReadWrite(grantee: iam.IGrantable): iam.Grant;

  /**
   * Grant the indicated permissions on this stream to the provided IAM principal.
   */
  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;

  /**
   * Return stream metric based from its metric name
   *
   * @param metricName name of the stream metric
   * @param props properties of the metric
   */
  metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of bytes retrieved from the Kinesis stream, measured over the specified time period. Minimum, Maximum,
   * and Average statistics represent the bytes in a single GetRecords operation for the stream in the specified time
   * period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The age of the last record in all GetRecords calls made against a Kinesis stream, measured over the specified time
   * period. Age is the difference between the current time and when the last record of the GetRecords call was written
   * to the stream. The Minimum and Maximum statistics can be used to track the progress of Kinesis consumer
   * applications. A value of zero indicates that the records being read are completely caught up with the stream.
   *
   * The metric defaults to maximum over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecordsIteratorAgeMilliseconds(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The time taken per GetRecords operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of records retrieved from the shard, measured over the specified time period. Minimum, Maximum, and
   * Average statistics represent the records in a single GetRecords operation for the stream in the specified time
   * period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of successful GetRecords operations per stream, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of bytes successfully put to the Kinesis stream over the specified time period. This metric includes
   * bytes from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the bytes in a
   * single put operation for the stream in the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricIncomingBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of records successfully put to the Kinesis stream over the specified time period. This metric includes
   * record counts from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the
   * records in a single put operation for the stream in the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricIncomingRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of bytes put to the Kinesis stream using the PutRecord operation over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The time taken per PutRecord operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of successful PutRecord operations per Kinesis stream, measured over the specified time period. Average
   * reflects the percentage of successful writes to a stream.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of bytes put to the Kinesis stream using the PutRecords operation over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The time taken per PutRecords operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   *  The number of PutRecords operations where at least one record succeeded, per Kinesis stream, measured over the
   *  specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The total number of records sent in a PutRecords operation per Kinesis data stream, measured over the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of successful records in a PutRecords operation per Kinesis data stream, measured over the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of records rejected due to internal failures in a PutRecords operation per Kinesis data stream,
   * measured over the specified time period. Occasional internal failures are to be expected and should be retried.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of records rejected due to throttling in a PutRecords operation per Kinesis data stream, measured over
   * the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of GetRecords calls throttled for the stream over the specified time period. The most commonly used
   * statistic for this metric is Average.
   *
   * When the Minimum statistic has a value of 1, all records were throttled for the stream during the specified time
   * period.
   *
   * When the Maximum statistic has a value of 0 (zero), no records were throttled for the stream during the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties
   *
   * @param props properties of the metric
   *
   */
  metricReadProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of records rejected due to throttling for the stream over the specified time period. This metric
   * includes throttling from PutRecord and PutRecords operations.
   *
   * When the Minimum statistic has a non-zero value, records were being throttled for the stream during the specified
   * time period.
   *
   * When the Maximum statistic has a value of 0 (zero), no records were being throttled for the stream during the
   * specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricWriteProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
}

/**
 * A reference to a stream. The easiest way to instantiate is to call
 * `stream.export()`. Then, the consumer can use `Stream.import(this, ref)` and
 * get a `Stream`.
 */
export interface StreamAttributes {
  /**
   * The ARN of the stream.
   */
  readonly streamArn: string;

  /**
   * The KMS key securing the contents of the stream if encryption is enabled.
   *
   * @default - No encryption
   */
  readonly encryptionKey?: kms.IKey;
}

/**
 * Represents a Kinesis Stream.
 */
abstract class StreamBase extends Resource implements IStream {
  /**
   * The ARN of the stream.
   */
  public abstract readonly streamArn: string;

  /**
   * The name of the stream
   */
  public abstract readonly streamName: string;

  /**
   * Optional KMS encryption key associated with this stream.
   */
  public abstract readonly encryptionKey?: kms.IKey;

  /**
   * Indicates if a stream resource policy should automatically be created upon
   * the first call to `addToResourcePolicy`.
   *
   * Set by subclasses.
   */
  protected abstract readonly autoCreatePolicy: boolean;

  private resourcePolicy?: ResourcePolicy;

  constructor(scope: Construct, id: string, props: ResourceProps = {}) {
    super(scope, id, props);

    this.node.addValidation({ validate: () => this.resourcePolicy?.document.validateForResourcePolicy() ?? [] });
  }

  /**
   * Adds a statement to the IAM resource policy associated with this stream.
   *
   * If this stream was created in this stack (`new Strem`), a resource policy
   * will be automatically created upon the first call to `addToResourcePolicy`. If
   * the stream is imported (`Stream.import`), then this is a no-op.
   */
  public addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {
    if (!this.resourcePolicy && this.autoCreatePolicy) {
      this.resourcePolicy = new ResourcePolicy(this, 'Policy', { stream: this });
    }

    if (this.resourcePolicy) {
      this.resourcePolicy.document.addStatements(statement);
      return { statementAdded: true, policyDependable: this.resourcePolicy };
    }
    return { statementAdded: false };
  }

  /**
   * Grant read permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to ues the key to decrypt the
   * contents of the stream will also be granted.
   */
  public grantRead(grantee: iam.IGrantable) {
    const ret = this.grant(grantee, ...READ_OPERATIONS);

    if (this.encryptionKey) {
      this.encryptionKey.grantDecrypt(grantee);
    }

    return ret;
  }

  /**
   * Grant write permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to ues the key to encrypt the
   * contents of the stream will also be granted.
   */
  public grantWrite(grantee: iam.IGrantable) {
    const ret = this.grant(grantee, ...WRITE_OPERATIONS);
    this.encryptionKey?.grantEncrypt(grantee);

    return ret;
  }

  /**
   * Grants read/write permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to use the key for
   * encrypt/decrypt will also be granted.
   */
  public grantReadWrite(grantee: iam.IGrantable) {
    const ret = this.grant(grantee, ...Array.from(new Set([...READ_OPERATIONS, ...WRITE_OPERATIONS])));
    this.encryptionKey?.grantEncryptDecrypt(grantee);

    return ret;
  }

  /**
   * Grant the indicated permissions on this stream to the given IAM principal (Role/Group/User).
   */
  public grant(grantee: iam.IGrantable, ...actions: string[]) {
    return iam.Grant.addToPrincipal({
      grantee,
      actions,
      resourceArns: [this.streamArn],
      scope: this,
    });
  }

  /**
   * Return stream metric based from its metric name
   *
   * @param metricName name of the stream metric
   * @param props properties of the metric
   */
  public metric(metricName: string, props?: cloudwatch.MetricOptions) {
    return new cloudwatch.Metric({
      namespace: 'AWS/Kinesis',
      metricName,
      dimensionsMap: {
        StreamName: this.streamName,
      },
      ...props,
    }).attachTo(this);
  }

  /**
   * The number of bytes retrieved from the Kinesis stream, measured over the specified time period. Minimum, Maximum,
   * and Average statistics represent the bytes in a single GetRecords operation for the stream in the specified time
   * period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecordsBytes(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.getRecordsBytesAverage, props);
  }

  /**
   * The age of the last record in all GetRecords calls made against a Kinesis stream, measured over the specified time
   * period. Age is the difference between the current time and when the last record of the GetRecords call was written
   * to the stream. The Minimum and Maximum statistics can be used to track the progress of Kinesis consumer
   * applications. A value of zero indicates that the records being read are completely caught up with the stream.
   *
   * The metric defaults to maximum over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecordsIteratorAgeMilliseconds(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.getRecordsIteratorAgeMillisecondsMaximum, props);
  }

  /**
   * The number of successful GetRecords operations per stream, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecordsSuccess(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.getRecordsSuccessAverage, props);
  }

  /**
   * The number of records retrieved from the shard, measured over the specified time period. Minimum, Maximum, and
   * Average statistics represent the records in a single GetRecords operation for the stream in the specified time
   * period.
   *
   * average
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.getRecordsRecordsAverage, props);
  }

  /**
   * The number of successful GetRecords operations per stream, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecordsLatency(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.getRecordsLatencyAverage, props);
  }

  /**
   * The number of bytes put to the Kinesis stream using the PutRecord operation over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordBytes(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordBytesAverage, props);
  }

  /**
   * The time taken per PutRecord operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordLatency(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordLatencyAverage, props);
  }

  /**
   * The number of successful PutRecord operations per Kinesis stream, measured over the specified time period. Average
   * reflects the percentage of successful writes to a stream.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordSuccess(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordSuccessAverage, props);
  }

  /**
   * The number of bytes put to the Kinesis stream using the PutRecords operation over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsBytes(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordsBytesAverage, props);
  }

  /**
   * The time taken per PutRecords operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsLatency(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordsLatencyAverage, props);
  }

  /**
   *  The number of PutRecords operations where at least one record succeeded, per Kinesis stream, measured over the
   *  specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsSuccess(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordsSuccessAverage, props);
  }

  /**
   * The total number of records sent in a PutRecords operation per Kinesis data stream, measured over the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordsTotalRecordsAverage, props);
  }

  /**
   * The number of successful records in a PutRecords operation per Kinesis data stream, measured over the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordsSuccessfulRecordsAverage, props);
  }

  /**
   * The number of records rejected due to internal failures in a PutRecords operation per Kinesis data stream,
   * measured over the specified time period. Occasional internal failures are to be expected and should be retried.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordsFailedRecordsAverage, props);
  }

  /**
   * The number of records rejected due to throttling in a PutRecords operation per Kinesis data stream, measured over
   * the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.putRecordsThrottledRecordsAverage, props);
  }

  /**
   * The number of bytes successfully put to the Kinesis stream over the specified time period. This metric includes
   * bytes from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the bytes in a
   * single put operation for the stream in the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricIncomingBytes(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.incomingBytesAverage, props);
  }

  /**
   * The number of records successfully put to the Kinesis stream over the specified time period. This metric includes
   * record counts from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the
   * records in a single put operation for the stream in the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricIncomingRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.incomingRecordsAverage, props);
  }

  /**
   * The number of GetRecords calls throttled for the stream over the specified time period. The most commonly used
   * statistic for this metric is Average.
   *
   * When the Minimum statistic has a value of 1, all records were throttled for the stream during the specified time
   * period.
   *
   * When the Maximum statistic has a value of 0 (zero), no records were throttled for the stream during the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties
   *
   * @param props properties of the metric
   *
   */
  public metricReadProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.readProvisionedThroughputExceededAverage, props);
  }

  /**
   * The number of records rejected due to throttling for the stream over the specified time period. This metric
   * includes throttling from PutRecord and PutRecords operations.
   *
   * When the Minimum statistic has a non-zero value, records were being throttled for the stream during the specified
   * time period.
   *
   * When the Maximum statistic has a value of 0 (zero), no records were being throttled for the stream during the
   * specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricWriteProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(KinesisMetrics.writeProvisionedThroughputExceededAverage, props);
  }

  // create metrics based on generated KinesisMetrics static methods
  private metricFromCannedFunction(
    createCannedProps: (dimensions: { StreamName: string }) => cloudwatch.MetricProps,
    props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return new cloudwatch.Metric({
      ...createCannedProps({ StreamName: this.streamName }),
      ...props,
    }).attachTo(this);
  }

}

/**
 * Properties for a Kinesis Stream
 */
export interface StreamProps {
  /**
   * Enforces a particular physical stream name.
   * @default <generated>
   */
  readonly streamName?: string;

  /**
   * The number of hours for the data records that are stored in shards to remain accessible.
   * @default Duration.hours(24)
   */
  readonly retentionPeriod?: Duration;

  /**
   * The number of shards for the stream.
   *
   * Can only be provided if streamMode is Provisioned.
   *
   * @default 1
   */
  readonly shardCount?: number;

  /**
   * The kind of server-side encryption to apply to this stream.
   *
   * If you choose KMS, you can specify a KMS key via `encryptionKey`. If
   * encryption key is not specified, a key will automatically be created.
   *
   * @default - StreamEncryption.KMS if encrypted Streams are supported in the region
   *   or StreamEncryption.UNENCRYPTED otherwise.
   *   StreamEncryption.KMS if an encryption key is supplied through the encryptionKey property
   */
  readonly encryption?: StreamEncryption;

  /**
   * External KMS key to use for stream encryption.
   *
   * The 'encryption' property must be set to "Kms".
   *
   * @default - Kinesis Data Streams master key ('/alias/aws/kinesis').
   *   If encryption is set to StreamEncryption.KMS and this property is undefined, a new KMS key
   *   will be created and associated with this stream.
   */
  readonly encryptionKey?: kms.IKey;

  /**
   * The capacity mode of this stream.
   *
   * @default StreamMode.PROVISIONED
   */
  readonly streamMode?: StreamMode;

  /**
   * Policy to apply when the stream is removed from the stack.
   *
   * @default RemovalPolicy.RETAIN
   */
  readonly removalPolicy?: RemovalPolicy;
}

/**
 * A Kinesis stream. Can be encrypted with a KMS key.
 */
export class Stream extends StreamBase {

  /**
   * Import an existing Kinesis Stream provided an ARN
   *
   * @param scope The parent creating construct (usually `this`).
   * @param id The construct's name
   * @param streamArn Stream ARN (i.e. arn:aws:kinesis:<region>:<account-id>:stream/Foo)
   */
  public static fromStreamArn(scope: Construct, id: string, streamArn: string): IStream {
    return Stream.fromStreamAttributes(scope, id, { streamArn });
  }

  /**
   * Creates a Stream construct that represents an external stream.
   *
   * @param scope The parent creating construct (usually `this`).
   * @param id The construct's name.
   * @param attrs Stream import properties
   */
  public static fromStreamAttributes(scope: Construct, id: string, attrs: StreamAttributes): IStream {
    class Import extends StreamBase {
      public readonly streamArn = attrs.streamArn;
      public readonly streamName = Stack.of(scope).splitArn(attrs.streamArn, ArnFormat.SLASH_RESOURCE_NAME).resourceName!;
      public readonly encryptionKey = attrs.encryptionKey;

      protected readonly autoCreatePolicy = false;
    }

    return new Import(scope, id, {
      environmentFromArn: attrs.streamArn,
    });
  }

  public readonly streamArn: string;
  public readonly streamName: string;
  public readonly encryptionKey?: kms.IKey;

  private readonly stream: CfnStream;

  protected readonly autoCreatePolicy = true;

  constructor(scope: Construct, id: string, props: StreamProps = {}) {
    super(scope, id, {
      physicalName: props.streamName,
    });

    let shardCount = props.shardCount;
    const streamMode = props.streamMode;

    if (streamMode === StreamMode.ON_DEMAND && shardCount !== undefined) {
      throw new Error(`streamMode must be set to ${StreamMode.PROVISIONED} (default) when specifying shardCount`);
    }
    if ((streamMode === StreamMode.PROVISIONED || streamMode === undefined) && shardCount === undefined) {
      shardCount = 1;
    }

    const retentionPeriodHours = props.retentionPeriod?.toHours() ?? 24;
    if (!Token.isUnresolved(retentionPeriodHours)) {
      if (retentionPeriodHours < 24 || retentionPeriodHours > 8760) {
        throw new Error(`retentionPeriod must be between 24 and 8760 hours. Received ${retentionPeriodHours}`);
      }
    }

    const { streamEncryption, encryptionKey } = this.parseEncryption(props);

    this.stream = new CfnStream(this, 'Resource', {
      name: this.physicalName,
      retentionPeriodHours,
      shardCount,
      streamEncryption,
      ...(props.streamMode !== undefined
        ? {
          streamModeDetails: { streamMode: props.streamMode },
        }
        : undefined),
    });
    this.stream.applyRemovalPolicy(props.removalPolicy);

    this.streamArn = this.getResourceArnAttribute(this.stream.attrArn, {
      service: 'kinesis',
      resource: 'stream',
      resourceName: this.physicalName,
    });
    this.streamName = this.getResourceNameAttribute(this.stream.ref);

    this.encryptionKey = encryptionKey;
  }

  /**
   * Set up key properties and return the Stream encryption property from the
   * user's configuration.
   */
  private parseEncryption(props: StreamProps): {
    streamEncryption?: CfnStream.StreamEncryptionProperty | IResolvable;
    encryptionKey?: kms.IKey;
  } {

    // if encryption properties are not set, default to KMS in regions where KMS is available
    if (!props.encryption && !props.encryptionKey) {

      const conditionName = 'AwsCdkKinesisEncryptedStreamsUnsupportedRegions';
      const existing = Stack.of(this).node.tryFindChild(conditionName);

      // create a single condition for the Stack
      if (!existing) {
        new CfnCondition(Stack.of(this), conditionName, {
          expression: Fn.conditionOr(
            Fn.conditionEquals(Aws.REGION, 'cn-north-1'),
            Fn.conditionEquals(Aws.REGION, 'cn-northwest-1'),
          ),
        });
      }

      return {
        streamEncryption: Fn.conditionIf(conditionName,
          Aws.NO_VALUE,
          { EncryptionType: 'KMS', KeyId: 'alias/aws/kinesis' }),
      };
    }

    // default based on whether encryption key is specified
    const encryptionType = props.encryption ??
      (props.encryptionKey ? StreamEncryption.KMS : StreamEncryption.UNENCRYPTED);

    // if encryption key is set, encryption must be set to KMS.
    if (encryptionType !== StreamEncryption.KMS && props.encryptionKey) {
      throw new Error(`encryptionKey is specified, so 'encryption' must be set to KMS (value: ${encryptionType})`);
    }

    if (encryptionType === StreamEncryption.UNENCRYPTED) {
      return {};
    }

    if (encryptionType === StreamEncryption.MANAGED) {
      const encryption = { encryptionType: 'KMS', keyId: 'alias/aws/kinesis' };
      return { streamEncryption: encryption };
    }

    if (encryptionType === StreamEncryption.KMS) {
      const encryptionKey = props.encryptionKey || new kms.Key(this, 'Key', {
        description: `Created by ${this.node.path}`,
      });

      const streamEncryption: CfnStream.StreamEncryptionProperty = {
        encryptionType: 'KMS',
        keyId: encryptionKey.keyArn,
      };
      return { encryptionKey, streamEncryption };
    }

    throw new Error(`Unexpected 'encryptionType': ${encryptionType}`);
  }
}

/**
 * What kind of server-side encryption to apply to this stream
 */
export enum StreamEncryption {
  /**
   * Records in the stream are not encrypted.
   */
  UNENCRYPTED = 'NONE',

  /**
   * Server-side encryption with a KMS key managed by the user.
   * If `encryptionKey` is specified, this key will be used, otherwise, one will be defined.
   */
  KMS = 'KMS',

  /**
   * Server-side encryption with a master key managed by Amazon Kinesis
   */
  MANAGED = 'MANAGED',
}

/**
 * Specifies the capacity mode to apply to this stream.
 */
export enum StreamMode {
  /**
   * Specify the provisioned capacity mode. The stream will have `shardCount` shards unless
   * modified and will be billed according to the provisioned capacity.
   */
  PROVISIONED = 'PROVISIONED',

  /**
   * Specify the on-demand capacity mode. The stream will autoscale and be billed according to the
   * volume of data ingested and retrieved.
   */
  ON_DEMAND = 'ON_DEMAND',
}

```

## Reference Documents
**CDKTF Type Declarations:**:
Strictly adhere to the following type declarations for relevant CDKTF Resources:
```typescript
// kinesis-stream
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface KinesisStreamConfig extends cdktf.TerraformMetaArguments {
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#arn KinesisStream#arn}
    */
    readonly arn?: string;
    /** (Optional) The encryption type to use. The only acceptable values are `NONE` or `KMS`. The default value is `NONE`. */
    readonly encryptionType?: string;
    /** (Optional) A boolean that indicates all registered consumers should be deregistered from the stream so that the stream can be destroyed without error. The default value is `false`. */
    readonly enforceConsumerDeletion?: boolean | cdktf.IResolvable;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#id KinesisStream#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /** (Optional) The GUID for the customer-managed KMS key to use for encryption. You can also use a Kinesis-owned master key by specifying the alias `alias/aws/kinesis`. */
    readonly kmsKeyId?: string;
    /** (Required) A name to identify the stream. This is unique to the AWS account and region the Stream is created in. * `shardCount`  (Optional) The number of shards that the stream will use. If the `streamMode` is `PROVISIONED`, this field is required. Amazon has guidelines for specifying the Stream size that should be referenced when creating a Kinesis stream. See [Amazon Kinesis Streams][2] for more. */
    readonly name: string;
    /** (Optional) Length of time data records are accessible after they are added to the stream. The maximum value of a stream's retention period is 8760 hours. Minimum value is 24. Default is 24. */
    readonly retentionPeriod?: number;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#shard_count KinesisStream#shard_count}
    */
    readonly shardCount?: number;
    /** (Optional) A list of shard-level CloudWatch metrics which can be enabled for the stream. See [Monitoring with CloudWatch][3] for more. Note that the value ALL should not be used; instead you should provide an explicit list of metrics you wish to enable. */
    readonly shardLevelMetrics?: string[];
    /** (Optional) A map of tags to assign to the resource. If configured with a provider [`defaultTags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level. ### stream_mode_details Configuration Block */
    readonly tags?: {
        [key: string]: string;
    };
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#tags_all KinesisStream#tags_all}
    */
    readonly tagsAll?: {
        [key: string]: string;
    };
    /** (Optional) Indicates the [capacity mode](https://docs.aws.amazon.com/streams/latest/dev/how-do-i-size-a-stream.html) of the data stream. Detailed below. */
    readonly streamModeDetails?: KinesisStreamStreamModeDetails;
    /**
    * timeouts block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#timeouts KinesisStream#timeouts}
    */
    readonly timeouts?: KinesisStreamTimeouts;
}
export interface KinesisStreamStreamModeDetails {
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#stream_mode KinesisStream#stream_mode}
    */
    readonly streamMode: string;
}
export declare function kinesisStreamStreamModeDetailsToTerraform(struct?: KinesisStreamStreamModeDetailsOutputReference | KinesisStreamStreamModeDetails): any;
export declare function kinesisStreamStreamModeDetailsToHclTerraform(struct?: KinesisStreamStreamModeDetailsOutputReference | KinesisStreamStreamModeDetails): any;
export declare class KinesisStreamStreamModeDetailsOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): KinesisStreamStreamModeDetails | undefined;
    set internalValue(value: KinesisStreamStreamModeDetails | undefined);
    private _streamMode?;
    get streamMode(): string;
    set streamMode(value: string);
    get streamModeInput(): string | undefined;
}
export interface KinesisStreamTimeouts {
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#create KinesisStream#create}
    */
    readonly create?: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#delete KinesisStream#delete}
    */
    readonly delete?: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#update KinesisStream#update}
    */
    readonly update?: string;
}
export declare function kinesisStreamTimeoutsToTerraform(struct?: KinesisStreamTimeouts | cdktf.IResolvable): any;
export declare function kinesisStreamTimeoutsToHclTerraform(struct?: KinesisStreamTimeouts | cdktf.IResolvable): any;
export declare class KinesisStreamTimeoutsOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    private resolvableValue?;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): KinesisStreamTimeouts | cdktf.IResolvable | undefined;
    set internalValue(value: KinesisStreamTimeouts | cdktf.IResolvable | undefined);
    private _create?;
    get create(): string;
    set create(value: string);
    resetCreate(): void;
    get createInput(): string | undefined;
    private _delete?;
    get delete(): string;
    set delete(value: string);
    resetDelete(): void;
    get deleteInput(): string | undefined;
    private _update?;
    get update(): string;
    set update(value: string);
    resetUpdate(): void;
    get updateInput(): string | undefined;
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream aws_kinesis_stream}
*/
export declare class KinesisStream extends cdktf.TerraformResource {
    static readonly tfResourceType = "aws_kinesis_stream";
    /**
    * Generates CDKTF code for importing a KinesisStream resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the KinesisStream to import
    * @param importFromId The id of the existing KinesisStream that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the KinesisStream to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/kinesis_stream aws_kinesis_stream} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options KinesisStreamConfig
    */
    constructor(scope: Construct, id: string, config: KinesisStreamConfig);
    private _arn?;
    get arn(): string;
    set arn(value: string);
    resetArn(): void;
    get arnInput(): string | undefined;
    private _encryptionType?;
    get encryptionType(): string;
    set encryptionType(value: string);
    resetEncryptionType(): void;
    get encryptionTypeInput(): string | undefined;
    private _enforceConsumerDeletion?;
    get enforceConsumerDeletion(): boolean | cdktf.IResolvable;
    set enforceConsumerDeletion(value: boolean | cdktf.IResolvable);
    resetEnforceConsumerDeletion(): void;
    get enforceConsumerDeletionInput(): boolean | cdktf.IResolvable | undefined;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    private _kmsKeyId?;
    get kmsKeyId(): string;
    set kmsKeyId(value: string);
    resetKmsKeyId(): void;
    get kmsKeyIdInput(): string | undefined;
    private _name?;
    get name(): string;
    set name(value: string);
    get nameInput(): string | undefined;
    private _retentionPeriod?;
    get retentionPeriod(): number;
    set retentionPeriod(value: number);
    resetRetentionPeriod(): void;
    get retentionPeriodInput(): number | undefined;
    private _shardCount?;
    get shardCount(): number;
    set shardCount(value: number);
    resetShardCount(): void;
    get shardCountInput(): number | undefined;
    private _shardLevelMetrics?;
    get shardLevelMetrics(): string[];
    set shardLevelMetrics(value: string[]);
    resetShardLevelMetrics(): void;
    get shardLevelMetricsInput(): string[] | undefined;
    private _tags?;
    get tags(): {
        [key: string]: string;
    };
    set tags(value: {
        [key: string]: string;
    });
    resetTags(): void;
    get tagsInput(): {
        [key: string]: string;
    } | undefined;
    private _tagsAll?;
    get tagsAll(): {
        [key: string]: string;
    };
    set tagsAll(value: {
        [key: string]: string;
    });
    resetTagsAll(): void;
    get tagsAllInput(): {
        [key: string]: string;
    } | undefined;
    private _streamModeDetails;
    get streamModeDetails(): KinesisStreamStreamModeDetailsOutputReference;
    putStreamModeDetails(value: KinesisStreamStreamModeDetails): void;
    resetStreamModeDetails(): void;
    get streamModeDetailsInput(): KinesisStreamStreamModeDetails | undefined;
    private _timeouts;
    get timeouts(): KinesisStreamTimeoutsOutputReference;
    putTimeouts(value: KinesisStreamTimeouts): void;
    resetTimeouts(): void;
    get timeoutsInput(): cdktf.IResolvable | KinesisStreamTimeouts | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}

```
**AWS CDK Type Declarations:**
Refer to the following Reference declarations used by the AWSCDK constructs:
```typescript
// kinesis.generated.d.ts
import * as cdk from "../../core";
import * as constructs from "constructs";
import * as cfn_parse from "../../core/lib/helpers-internal";
/**
 * Creates a Kinesis stream that captures and transports data records that are emitted from data sources.
 *
 * For information about creating streams, see [CreateStream](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_CreateStream.html) in the Amazon Kinesis API Reference.
 *
 * @cloudformationResource AWS::Kinesis::Stream
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesis-stream.html
 */
export declare class CfnStream extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
    /**
     * The CloudFormation resource type name for this resource class.
     */
    static readonly CFN_RESOURCE_TYPE_NAME: string;
    /**
     * Build a CfnStream from CloudFormation properties
     *
     * A factory method that creates a new instance of this class from an object
     * containing the CloudFormation properties of this resource.
     * Used in the @aws-cdk/cloudformation-include module.
     *
     * @internal
     */
    static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnStream;
    /**
     * The Amazon resource name (ARN) of the Kinesis stream, such as `arn:aws:kinesis:us-east-2:123456789012:stream/mystream` .
     *
     * @cloudformationAttribute Arn
     */
    readonly attrArn: string;
    /**
     * The name of the Kinesis stream.
     */
    name?: string;
    /**
     * The number of hours for the data records that are stored in shards to remain accessible.
     */
    retentionPeriodHours?: number;
    /**
     * The number of shards that the stream uses.
     */
    shardCount?: number;
    /**
     * When specified, enables or updates server-side encryption using an AWS KMS key for a specified stream.
     */
    streamEncryption?: cdk.IResolvable | CfnStream.StreamEncryptionProperty;
    /**
     * Specifies the capacity mode to which you want to set your data stream.
     */
    streamModeDetails?: cdk.IResolvable | CfnStream.StreamModeDetailsProperty;
    /**
     * Tag Manager which manages the tags for this resource
     */
    readonly tags: cdk.TagManager;
    /**
     * An arbitrary set of tags (keyvalue pairs) to associate with the Kinesis stream.
     */
    tagsRaw?: Array<cdk.CfnTag>;
    /**
     * @param scope Scope in which this resource is defined
     * @param id Construct identifier for this resource (unique in its scope)
     * @param props Resource properties
     */
    constructor(scope: constructs.Construct, id: string, props?: CfnStreamProps);
    protected get cfnProperties(): Record<string, any>;
    /**
     * Examines the CloudFormation resource and discloses attributes
     *
     * @param inspector tree inspector to collect and process attributes
     */
    inspect(inspector: cdk.TreeInspector): void;
    protected renderProperties(props: Record<string, any>): Record<string, any>;
}
export declare namespace CfnStream {
    /**
     * Specifies the capacity mode to which you want to set your data stream.
     *
     * Currently, in Kinesis Data Streams, you can choose between an *on-demand* capacity mode and a *provisioned* capacity mode for your data streams.
     *
     * @struct
     * @stability external
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streammodedetails.html
     */
    interface StreamModeDetailsProperty {
        /**
         * Specifies the capacity mode to which you want to set your data stream.
         *
         * Currently, in Kinesis Data Streams, you can choose between an *on-demand* capacity mode and a *provisioned* capacity mode for your data streams.
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streammodedetails.html#cfn-kinesis-stream-streammodedetails-streammode
         */
        readonly streamMode: string;
    }
    /**
     * Enables or updates server-side encryption using an AWS KMS key for a specified stream.
     *
     * > When invoking this API, you must use either the `StreamARN` or the `StreamName` parameter, or both. It is recommended that you use the `StreamARN` input parameter when you invoke this API.
     *
     * Starting encryption is an asynchronous operation. Upon receiving the request, Kinesis Data Streams returns immediately and sets the status of the stream to `UPDATING` . After the update is complete, Kinesis Data Streams sets the status of the stream back to `ACTIVE` . Updating or applying encryption normally takes a few seconds to complete, but it can take minutes. You can continue to read and write data to your stream while its status is `UPDATING` . Once the status of the stream is `ACTIVE` , encryption begins for records written to the stream.
     *
     * API Limits: You can successfully apply a new AWS KMS key for server-side encryption 25 times in a rolling 24-hour period.
     *
     * Note: It can take up to 5 seconds after the stream is in an `ACTIVE` status before all records written to the stream are encrypted. After you enable encryption, you can verify that encryption is applied by inspecting the API response from `PutRecord` or `PutRecords` .
     *
     * @struct
     * @stability external
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html
     */
    interface StreamEncryptionProperty {
        /**
         * The encryption type to use.
         *
         * The only valid value is `KMS` .
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html#cfn-kinesis-stream-streamencryption-encryptiontype
         */
        readonly encryptionType: string;
        /**
         * The GUID for the customer-managed AWS KMS key to use for encryption.
         *
         * This value can be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either an alias or a key, or an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data Streams by specifying the alias `aws/kinesis` .
         *
         * - Key ARN example: `arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012`
         * - Alias ARN example: `arn:aws:kms:us-east-1:123456789012:alias/MyAliasName`
         * - Globally unique key ID example: `12345678-1234-1234-1234-123456789012`
         * - Alias name example: `alias/MyAliasName`
         * - Master key owned by Kinesis Data Streams: `alias/aws/kinesis`
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html#cfn-kinesis-stream-streamencryption-keyid
         */
        readonly keyId: string;
    }
}
/**
 * Properties for defining a `CfnStream`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesis-stream.html
 */
export interface CfnStreamProps {
    /**
     * The name of the Kinesis stream.
     *
     * If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the stream name. For more information, see [Name Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) .
     *
     * If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesis-stream.html#cfn-kinesis-stream-name
     */
    readonly name?: string;
    /**
     * The number of hours for the data records that are stored in shards to remain accessible.
     *
     * The default value is 24. For more information about the stream retention period, see [Changing the Data Retention Period](https://docs.aws.amazon.com/streams/latest/dev/kinesis-extended-retention.html) in the Amazon Kinesis Developer Guide.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesis-stream.html#cfn-kinesis-stream-retentionperiodhours
     */
    readonly retentionPeriodHours?: number;
    /**
     * The number of shards that the stream uses.
     *
     * For greater provisioned throughput, increase the number of shards.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesis-stream.html#cfn-kinesis-stream-shardcount
     */
    readonly shardCount?: number;
    /**
     * When specified, enables or updates server-side encryption using an AWS KMS key for a specified stream.
     *
     * Removing this property from your stack template and updating your stack disables encryption.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesis-stream.html#cfn-kinesis-stream-streamencryption
     */
    readonly streamEncryption?: cdk.IResolvable | CfnStream.StreamEncryptionProperty;
    /**
     * Specifies the capacity mode to which you want to set your data stream.
     *
     * Currently, in Kinesis Data Streams, you can choose between an *on-demand* capacity mode and a *provisioned* capacity mode for your data streams.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesis-stream.html#cfn-kinesis-stream-streammodedetails
     */
    readonly streamModeDetails?: cdk.IResolvable | CfnStream.StreamModeDetailsProperty;
    /**
     * An arbitrary set of tags (keyvalue pairs) to associate with the Kinesis stream.
     *
     * For information about constraints for this property, see [Tag Restrictions](https://docs.aws.amazon.com/streams/latest/dev/tagging.html#tagging-restrictions) in the *Amazon Kinesis Developer Guide* .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kinesis-stream.html#cfn-kinesis-stream-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
}
;
;
;
;

```

## Simulated Assistant Response
Here is the converted code

```typescript
import { kinesisStream } from "@cdktf/provider-aws";
import { Fn, Token, TerraformLocal } from "cdktf";
import { Construct } from "constructs";
import { ArnFormat } from "../arn";
import {
  IAwsConstruct,
  AwsConstructBase,
  AwsConstructProps,
} from "../aws-construct";
import { AwsStack } from "../aws-stack";
import { KinesisMetrics } from "./kinesis-fixed-canned-metrics";
import { ResourcePolicy } from "./resource-policy";
import { Duration } from "../../duration";
import * as cloudwatch from "../cloudwatch";
import * as kms from "../encryption";
import * as iam from "../iam";

const READ_OPERATIONS = [
  "kinesis:DescribeStreamSummary",
  "kinesis:GetRecords",
  "kinesis:GetShardIterator",
  "kinesis:ListShards",
  "kinesis:SubscribeToShard",
  "kinesis:DescribeStream",
  "kinesis:ListStreams",
  "kinesis:DescribeStreamConsumer",
];

const WRITE_OPERATIONS = [
  "kinesis:ListShards",
  "kinesis:PutRecord",
  "kinesis:PutRecords",
];

/**
 * Outputs which may be registered for output via the Grid.
 */
export interface StreamOutputs {
  /**
   * The ARN of the stream.
   *
   * @attribute
   */
  readonly streamArn: string;

  /**
   * The name of the stream
   *
   * @attribute
   */
  readonly streamName: string;
}

/**
 * A Kinesis Stream
 */
export interface IStream extends IAwsConstruct {
  /** Strongly typed outputs */
  readonly streamOutputs: StreamOutputs;
  /**
   * The ARN of the stream.
   *
   * @attribute
   */
  readonly streamArn: string;

  /**
   * The name of the stream
   *
   * @attribute
   */
  readonly streamName: string;

  /**
   * Optional KMS encryption key associated with this stream.
   */
  readonly encryptionKey?: kms.IKey;

  /**
   * Adds a statement to the IAM resource policy associated with this stream.
   *
   * If this stream was created in this stack (`new Stream`), a resource policy
   * will be automatically created upon the first call to `addToResourcePolicy`. If
   * the stream is imported (`Stream.import`), then this is a no-op.
   */
  addToResourcePolicy(
    statement: iam.PolicyStatement,
  ): iam.AddToResourcePolicyResult;

  /**
   * Grant read permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to ues the key to decrypt the
   * contents of the stream will also be granted.
   */
  grantRead(grantee: iam.IGrantable): iam.Grant;

  /**
   * Grant write permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to ues the key to encrypt the
   * contents of the stream will also be granted.
   */
  grantWrite(grantee: iam.IGrantable): iam.Grant;

  /**
   * Grants read/write permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to use the key for
   * encrypt/decrypt will also be granted.
   */
  grantReadWrite(grantee: iam.IGrantable): iam.Grant;

  /**
   * Grant the indicated permissions on this stream to the provided IAM principal.
   */
  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;

  /**
   * Return stream metric based from its metric name
   *
   * @param metricName name of the stream metric
   * @param props properties of the metric
   */
  metric(
    metricName: string,
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric;

  /**
   * The number of bytes retrieved from the Kinesis stream, measured over the specified time period. Minimum, Maximum,
   * and Average statistics represent the bytes in a single GetRecords operation for the stream in the specified time
   * period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The age of the last record in all GetRecords calls made against a Kinesis stream, measured over the specified time
   * period. Age is the difference between the current time and when the last record of the GetRecords call was written
   * to the stream. The Minimum and Maximum statistics can be used to track the progress of Kinesis consumer
   * applications. A value of zero indicates that the records being read are completely caught up with the stream.
   *
   * The metric defaults to maximum over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecordsIteratorAgeMilliseconds(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric;

  /**
   * The time taken per GetRecords operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of records retrieved from the shard, measured over the specified time period. Minimum, Maximum, and
   * Average statistics represent the records in a single GetRecords operation for the stream in the specified time
   * period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of successful GetRecords operations per stream, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricGetRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of bytes successfully put to the Kinesis stream over the specified time period. This metric includes
   * bytes from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the bytes in a
   * single put operation for the stream in the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricIncomingBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of records successfully put to the Kinesis stream over the specified time period. This metric includes
   * record counts from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the
   * records in a single put operation for the stream in the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricIncomingRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of bytes put to the Kinesis stream using the PutRecord operation over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The time taken per PutRecord operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of successful PutRecord operations per Kinesis stream, measured over the specified time period. Average
   * reflects the percentage of successful writes to a stream.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The number of bytes put to the Kinesis stream using the PutRecords operation over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The time taken per PutRecords operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   *  The number of PutRecords operations where at least one record succeeded, per Kinesis stream, measured over the
   *  specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;

  /**
   * The total number of records sent in a PutRecords operation per Kinesis data stream, measured over the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsTotalRecords(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric;

  /**
   * The number of successful records in a PutRecords operation per Kinesis data stream, measured over the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsSuccessfulRecords(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric;

  /**
   * The number of records rejected due to internal failures in a PutRecords operation per Kinesis data stream,
   * measured over the specified time period. Occasional internal failures are to be expected and should be retried.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsFailedRecords(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric;

  /**
   * The number of records rejected due to throttling in a PutRecords operation per Kinesis data stream, measured over
   * the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordsThrottledRecords(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric;

  /**
   * The number of GetRecords calls throttled for the stream over the specified time period. The most commonly used
   * statistic for this metric is Average.
   *
   * When the Minimum statistic has a value of 1, all records were throttled for the stream during the specified time
   * period.
   *
   * When the Maximum statistic has a value of 0 (zero), no records were throttled for the stream during the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties
   *
   * @param props properties of the metric
   *
   */
  metricReadProvisionedThroughputExceeded(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric;

  /**
   * The number of records rejected due to throttling for the stream over the specified time period. This metric
   * includes throttling from PutRecord and PutRecords operations.
   *
   * When the Minimum statistic has a non-zero value, records were being throttled for the stream during the specified
   * time period.
   *
   * When the Maximum statistic has a value of 0 (zero), no records were being throttled for the stream during the
   * specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricWriteProvisionedThroughputExceeded(
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric;
}

/**
 * A reference to a stream. The easiest way to instantiate is to call
 * `stream.export()`. Then, the consumer can use `Stream.import(this, ref)` and
 * get a `Stream`.
 */
export interface StreamAttributes {
  /**
   * The ARN of the stream.
   */
  readonly streamArn: string;

  /**
   * The KMS key securing the contents of the stream if encryption is enabled.
   *
   * @default - No encryption
   */
  readonly encryptionKey?: kms.IKey;
}

/**
 * Represents a Kinesis Stream.
 */
abstract class StreamBase extends AwsConstructBase implements IStream {
  /**
   * The ARN of the stream.
   */
  public abstract readonly streamArn: string;

  /**
   * The name of the stream
   */
  public abstract readonly streamName: string;

  public get streamOutputs(): StreamOutputs {
    return {
      streamArn: this.streamArn,
      streamName: this.streamName,
    };
  }
  public get outputs(): Record<string, any> {
    return this.streamOutputs;
  }

  /**
   * Optional KMS encryption key associated with this stream.
   */
  public abstract readonly encryptionKey?: kms.IKey;

  /**
   * Indicates if a stream resource policy should automatically be created upon
   * the first call to `addToResourcePolicy`.
   *
   * Set by subclasses.
   */
  protected abstract readonly autoCreatePolicy: boolean;

  private resourcePolicy?: ResourcePolicy;

  constructor(scope: Construct, id: string, props: AwsConstructProps = {}) {
    super(scope, id, props);

    this.node.addValidation({
      validate: () =>
        this.resourcePolicy?.document.validateForResourcePolicy() ?? [],
    });
  }

  /**
   * Adds a statement to the IAM resource policy associated with this stream.
   *
   * If this stream was created in this stack (`new Strem`), a resource policy
   * will be automatically created upon the first call to `addToResourcePolicy`. If
   * the stream is imported (`Stream.import`), then this is a no-op.
   */
  public addToResourcePolicy(
    statement: iam.PolicyStatement,
  ): iam.AddToResourcePolicyResult {
    if (!this.resourcePolicy && this.autoCreatePolicy) {
      this.resourcePolicy = new ResourcePolicy(this, "Policy", {
        stream: this,
      });
    }

    if (this.resourcePolicy) {
      this.resourcePolicy.document.addStatements(statement);
      return { statementAdded: true, policyDependable: this.resourcePolicy };
    }
    return { statementAdded: false };
  }

  /**
   * Grant read permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to ues the key to decrypt the
   * contents of the stream will also be granted.
   */
  public grantRead(grantee: iam.IGrantable) {
    const ret = this.grant(grantee, ...READ_OPERATIONS);

    if (this.encryptionKey) {
      this.encryptionKey.grantDecrypt(grantee);
    }

    return ret;
  }

  /**
   * Grant write permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to ues the key to encrypt the
   * contents of the stream will also be granted.
   */
  public grantWrite(grantee: iam.IGrantable) {
    const ret = this.grant(grantee, ...WRITE_OPERATIONS);
    // this.encryptionKey?.grantEncrypt(grantee);

    return ret;
  }

  /**
   * Grants read/write permissions for this stream and its contents to an IAM
   * principal (Role/Group/User).
   *
   * If an encryption key is used, permission to use the key for
   * encrypt/decrypt will also be granted.
   */
  public grantReadWrite(grantee: iam.IGrantable) {
    const ret = this.grant(
      grantee,
      ...Array.from(new Set([...READ_OPERATIONS, ...WRITE_OPERATIONS])),
    );
    this.encryptionKey?.grantEncryptDecrypt(grantee);

    return ret;
  }

  /**
   * Grant the indicated permissions on this stream to the given IAM principal (Role/Group/User).
   */
  public grant(grantee: iam.IGrantable, ...actions: string[]) {
    return iam.Grant.addToPrincipal({
      grantee,
      actions,
      resourceArns: [this.streamArn],
      scope: this,
    });
  }

  /**
   * Return stream metric based from its metric name
   *
   * @param metricName name of the stream metric
   * @param props properties of the metric
   */
  public metric(metricName: string, props?: cloudwatch.MetricOptions) {
    return new cloudwatch.Metric({
      namespace: "AWS/Kinesis",
      metricName,
      dimensionsMap: {
        StreamName: this.streamName,
      },
      ...props,
    }).attachTo(this);
  }

  /**
   * The number of bytes retrieved from the Kinesis stream, measured over the specified time period. Minimum, Maximum,
   * and Average statistics represent the bytes in a single GetRecords operation for the stream in the specified time
   * period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecordsBytes(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.getRecordsBytesAverage,
      props,
    );
  }

  /**
   * The age of the last record in all GetRecords calls made against a Kinesis stream, measured over the specified time
   * period. Age is the difference between the current time and when the last record of the GetRecords call was written
   * to the stream. The Minimum and Maximum statistics can be used to track the progress of Kinesis consumer
   * applications. A value of zero indicates that the records being read are completely caught up with the stream.
   *
   * The metric defaults to maximum over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecordsIteratorAgeMilliseconds(
    props?: cloudwatch.MetricOptions,
  ) {
    return this.metricFromCannedFunction(
      KinesisMetrics.getRecordsIteratorAgeMillisecondsMaximum,
      props,
    );
  }

  /**
   * The number of successful GetRecords operations per stream, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecordsSuccess(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.getRecordsSuccessAverage,
      props,
    );
  }

  /**
   * The number of records retrieved from the shard, measured over the specified time period. Minimum, Maximum, and
   * Average statistics represent the records in a single GetRecords operation for the stream in the specified time
   * period.
   *
   * average
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.getRecordsRecordsAverage,
      props,
    );
  }

  /**
   * The number of successful GetRecords operations per stream, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricGetRecordsLatency(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.getRecordsLatencyAverage,
      props,
    );
  }

  /**
   * The number of bytes put to the Kinesis stream using the PutRecord operation over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordBytes(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordBytesAverage,
      props,
    );
  }

  /**
   * The time taken per PutRecord operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  metricPutRecordLatency(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordLatencyAverage,
      props,
    );
  }

  /**
   * The number of successful PutRecord operations per Kinesis stream, measured over the specified time period. Average
   * reflects the percentage of successful writes to a stream.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordSuccess(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordSuccessAverage,
      props,
    );
  }

  /**
   * The number of bytes put to the Kinesis stream using the PutRecords operation over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsBytes(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordsBytesAverage,
      props,
    );
  }

  /**
   * The time taken per PutRecords operation, measured over the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsLatency(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordsLatencyAverage,
      props,
    );
  }

  /**
   *  The number of PutRecords operations where at least one record succeeded, per Kinesis stream, measured over the
   *  specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsSuccess(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordsSuccessAverage,
      props,
    );
  }

  /**
   * The total number of records sent in a PutRecords operation per Kinesis data stream, measured over the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordsTotalRecordsAverage,
      props,
    );
  }

  /**
   * The number of successful records in a PutRecords operation per Kinesis data stream, measured over the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordsSuccessfulRecordsAverage,
      props,
    );
  }

  /**
   * The number of records rejected due to internal failures in a PutRecords operation per Kinesis data stream,
   * measured over the specified time period. Occasional internal failures are to be expected and should be retried.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordsFailedRecordsAverage,
      props,
    );
  }

  /**
   * The number of records rejected due to throttling in a PutRecords operation per Kinesis data stream, measured over
   * the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.putRecordsThrottledRecordsAverage,
      props,
    );
  }

  /**
   * The number of bytes successfully put to the Kinesis stream over the specified time period. This metric includes
   * bytes from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the bytes in a
   * single put operation for the stream in the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricIncomingBytes(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.incomingBytesAverage,
      props,
    );
  }

  /**
   * The number of records successfully put to the Kinesis stream over the specified time period. This metric includes
   * record counts from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the
   * records in a single put operation for the stream in the specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricIncomingRecords(props?: cloudwatch.MetricOptions) {
    return this.metricFromCannedFunction(
      KinesisMetrics.incomingRecordsAverage,
      props,
    );
  }

  /**
   * The number of GetRecords calls throttled for the stream over the specified time period. The most commonly used
   * statistic for this metric is Average.
   *
   * When the Minimum statistic has a value of 1, all records were throttled for the stream during the specified time
   * period.
   *
   * When the Maximum statistic has a value of 0 (zero), no records were throttled for the stream during the specified
   * time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties
   *
   * @param props properties of the metric
   *
   */
  public metricReadProvisionedThroughputExceeded(
    props?: cloudwatch.MetricOptions,
  ) {
    return this.metricFromCannedFunction(
      KinesisMetrics.readProvisionedThroughputExceededAverage,
      props,
    );
  }

  /**
   * The number of records rejected due to throttling for the stream over the specified time period. This metric
   * includes throttling from PutRecord and PutRecords operations.
   *
   * When the Minimum statistic has a non-zero value, records were being throttled for the stream during the specified
   * time period.
   *
   * When the Maximum statistic has a value of 0 (zero), no records were being throttled for the stream during the
   * specified time period.
   *
   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
   *
   * @param props properties of the metric
   */
  public metricWriteProvisionedThroughputExceeded(
    props?: cloudwatch.MetricOptions,
  ) {
    return this.metricFromCannedFunction(
      KinesisMetrics.writeProvisionedThroughputExceededAverage,
      props,
    );
  }

  // create metrics based on generated KinesisMetrics static methods
  private metricFromCannedFunction(
    createCannedProps: (dimensions: {
      StreamName: string;
    }) => cloudwatch.MetricProps,
    props?: cloudwatch.MetricOptions,
  ): cloudwatch.Metric {
    return new cloudwatch.Metric({
      ...createCannedProps({ StreamName: this.streamName }),
      ...props,
    }).attachTo(this);
  }
}

/**
 * Properties for a Kinesis Stream
 */
export interface StreamProps extends AwsConstructProps {
  /**
   * Enforces a particular physical stream name.
   * @default <generated>
   */
  readonly streamName?: string;

  /**
   * The number of hours for the data records that are stored in shards to remain accessible.
   * @default Duration.hours(24)
   */
  readonly retentionPeriod?: Duration;

  /**
   * The number of shards for the stream.
   *
   * Can only be provided if streamMode is Provisioned.
   *
   * @default 1
   */
  readonly shardCount?: number;

  /**
   * The kind of server-side encryption to apply to this stream.
   *
   * If you choose KMS, you can specify a KMS key via `encryptionKey`. If
   * encryption key is not specified, a key will automatically be created.
   *
   * @default - StreamEncryption.KMS if encrypted Streams are supported in the region
   *   or StreamEncryption.UNENCRYPTED otherwise.
   *   StreamEncryption.KMS if an encryption key is supplied through the encryptionKey property
   */
  readonly encryption?: StreamEncryption;

  /**
   * External KMS key to use for stream encryption.
   *
   * The 'encryption' property must be set to "Kms".
   *
   * @default - Kinesis Data Streams master key ('/alias/aws/kinesis').
   *   If encryption is set to StreamEncryption.KMS and this property is undefined, a new KMS key
   *   will be created and associated with this stream.
   */
  readonly encryptionKey?: kms.IKey;

  /**
   * The capacity mode of this stream.
   *
   * @default StreamMode.PROVISIONED
   */
  readonly streamMode?: StreamMode;
}

/**
 * A Kinesis stream. Can be encrypted with a KMS key.
 *
 * @resource aws_kinesis_stream
 */
export class Stream extends StreamBase {
  /**
   * Import an existing Kinesis Stream provided an ARN
   *
   * @param scope The parent creating construct (usually `this`).
   * @param id The construct's name
   * @param streamArn Stream ARN (i.e. arn:aws:kinesis:<region>:<account-id>:stream/Foo)
   */
  public static fromStreamArn(
    scope: Construct,
    id: string,
    streamArn: string,
  ): IStream {
    return Stream.fromStreamAttributes(scope, id, { streamArn });
  }

  /**
   * Creates a Stream construct that represents an external stream.
   *
   * @param scope The parent creating construct (usually `this`).
   * @param id The construct's name.
   * @param attrs Stream import properties
   */
  public static fromStreamAttributes(
    scope: Construct,
    id: string,
    attrs: StreamAttributes,
  ): IStream {
    class Import extends StreamBase {
      public readonly streamArn = attrs.streamArn;
      public readonly streamName = AwsStack.ofAwsConstruct(scope).splitArn(
        attrs.streamArn,
        ArnFormat.SLASH_RESOURCE_NAME,
      ).resourceName!;
      public readonly encryptionKey = attrs.encryptionKey;

      protected readonly autoCreatePolicy = false;
    }

    return new Import(scope, id, {
      environmentFromArn: attrs.streamArn,
    });
  }

  public readonly streamArn: string;
  public readonly streamName: string;
  public readonly encryptionKey?: kms.IKey;

  public readonly resource: kinesisStream.KinesisStream;

  protected readonly autoCreatePolicy = true;

  constructor(scope: Construct, id: string, props: StreamProps = {}) {
    super(scope, id, props);
    const name =
      props.streamName ||
      this.stack.uniqueResourceName(this, {
        prefix: this.gridUUID,
      });

    let shardCount = props.shardCount;
    const streamMode = props.streamMode;

    if (streamMode === StreamMode.ON_DEMAND && shardCount !== undefined) {
      throw new Error(
        `streamMode must be set to ${StreamMode.PROVISIONED} (default) when specifying shardCount`,
      );
    }
    if (
      (streamMode === StreamMode.PROVISIONED || streamMode === undefined) &&
      shardCount === undefined
    ) {
      shardCount = 1;
    }

    const retentionPeriodHours = props.retentionPeriod?.toHours() ?? 24;
    if (!Token.isUnresolved(retentionPeriodHours)) {
      if (retentionPeriodHours < 24 || retentionPeriodHours > 8760) {
        throw new Error(
          `retentionPeriod must be between 24 and 8760 hours. Received ${retentionPeriodHours}`,
        );
      }
    }

    const { streamEncryption, encryptionKey } = this.parseEncryption(props);
    this.resource = new kinesisStream.KinesisStream(this, "Resource", {
      name,
      retentionPeriod: retentionPeriodHours,
      shardCount,
      ...streamEncryption,
      ...(props.streamMode !== undefined
        ? {
            streamModeDetails: { streamMode: props.streamMode },
          }
        : undefined),
    });

    this.streamArn = this.resource.arn;
    this.streamName = this.resource.name;

    this.encryptionKey = encryptionKey;
  }

  /**
   * Set up key properties and return the Stream encryption property from the
   * user's configuration.
   */
  private parseEncryption(props: StreamProps): {
    streamEncryption?: StreamEncryptionProperty;
    encryptionKey?: kms.IKey;
  } {
    // if encryption properties are not set, default to KMS in regions where KMS is available
    if (!props.encryption && !props.encryptionKey) {
      const conditionName = "AwsCdkKinesisEncryptedStreamsUnsupportedRegions";
      let unsupportedRegionCondition = this.stack.node.tryFindChild(
        conditionName,
      ) as TerraformLocal;

      const unsupportedRegions = ["cn-north-1", "cn-northwest-1"];

      // create a single condition for the Stack
      if (!unsupportedRegionCondition) {
        unsupportedRegionCondition = new TerraformLocal(
          this.stack,
          conditionName,
          Fn.contains(unsupportedRegions, this.stack.region),
        );
      }

      return {
        streamEncryption: {
          encryptionType: conditionalString(
            unsupportedRegionCondition.expression,
            "KMS",
          ),
          kmsKeyId: conditionalString(
            unsupportedRegionCondition.expression,
            "alias/aws/kinesis",
          ),
        },
      };
    }

    // default based on whether encryption key is specified
    const encryptionType =
      props.encryption ??
      (props.encryptionKey
        ? StreamEncryption.KMS
        : StreamEncryption.UNENCRYPTED);

    // if encryption key is set, encryption must be set to KMS.
    if (encryptionType !== StreamEncryption.KMS && props.encryptionKey) {
      throw new Error(
        `encryptionKey is specified, so 'encryption' must be set to KMS (value: ${encryptionType})`,
      );
    }

    if (encryptionType === StreamEncryption.UNENCRYPTED) {
      return {};
    }

    if (encryptionType === StreamEncryption.MANAGED) {
      const encryption = {
        encryptionType: "KMS",
        kmsKeyId: "alias/aws/kinesis",
      };
      return { streamEncryption: encryption };
    }

    if (encryptionType === StreamEncryption.KMS) {
      const encryptionKey =
        props.encryptionKey ||
        new kms.Key(this, "Key", {
          description: `Created by ${this.node.path}`,
        });

      const streamEncryption: StreamEncryptionProperty = {
        encryptionType: "KMS",
        kmsKeyId: encryptionKey.keyArn,
      };
      return { encryptionKey, streamEncryption };
    }

    throw new Error(`Unexpected 'encryptionType': ${encryptionType}`);
  }
}

/**
 * Enables or updates server-side encryption using an AWS KMS key for a specified stream.
 *
 * > When invoking this API, you must use either the `StreamARN` or the `StreamName` parameter, or both. It is recommended that you use the `StreamARN` input parameter when you invoke this API.
 *
 * Starting encryption is an asynchronous operation. Upon receiving the request, Kinesis Data Streams returns immediately and sets the status of the stream to `UPDATING` . After the update is complete, Kinesis Data Streams sets the status of the stream back to `ACTIVE` . Updating or applying encryption normally takes a few seconds to complete, but it can take minutes. You can continue to read and write data to your stream while its status is `UPDATING` . Once the status of the stream is `ACTIVE` , encryption begins for records written to the stream.
 *
 * API Limits: You can successfully apply a new AWS KMS key for server-side encryption 25 times in a rolling 24-hour period.
 *
 * Note: It can take up to 5 seconds after the stream is in an `ACTIVE` status before all records written to the stream are encrypted. After you enable encryption, you can verify that encryption is applied by inspecting the API response from `PutRecord` or `PutRecords` .
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html
 */
export interface StreamEncryptionProperty {
  /**
   * The encryption type to use.
   *
   * The only valid value is `KMS` .
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html#cfn-kinesis-stream-streamencryption-encryptiontype
   */
  readonly encryptionType: string;

  /**
   * The GUID for the customer-managed AWS KMS key to use for encryption.
   *
   * This value can be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either an alias or a key, or an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data Streams by specifying the alias `aws/kinesis` .
   *
   * - Key ARN example: `arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012`
   * - Alias ARN example: `arn:aws:kms:us-east-1:123456789012:alias/MyAliasName`
   * - Globally unique key ID example: `12345678-1234-1234-1234-123456789012`
   * - Alias name example: `alias/MyAliasName`
   * - Master key owned by Kinesis Data Streams: `alias/aws/kinesis`
   *
   * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html#cfn-kinesis-stream-streamencryption-keyid
   */
  readonly kmsKeyId: string;
}

/**
 * What kind of server-side encryption to apply to this stream
 */
export enum StreamEncryption {
  /**
   * Records in the stream are not encrypted.
   */
  UNENCRYPTED = "NONE",

  /**
   * Server-side encryption with a KMS key managed by the user.
   * If `encryptionKey` is specified, this key will be used, otherwise, one will be defined.
   */
  KMS = "KMS",

  /**
   * Server-side encryption with a master key managed by Amazon Kinesis
   */
  MANAGED = "MANAGED",
}

/**
 * Specifies the capacity mode to apply to this stream.
 */
export enum StreamMode {
  /**
   * Specify the provisioned capacity mode. The stream will have `shardCount` shards unless
   * modified and will be billed according to the provisioned capacity.
   */
  PROVISIONED = "PROVISIONED",

  /**
   * Specify the on-demand capacity mode. The stream will autoscale and be billed according to the
   * volume of data ingested and retrieved.
   */
  ON_DEMAND = "ON_DEMAND",
}

/**
 * Set string based on expression
 *
 * @param expression expression to evaluate
 * @param value value to return if expression is true, otherwise null
 */
function conditionalString(expression: any, value: string): string {
  return Token.asString(Fn.conditional(expression, Token.nullValue(), value));
}

```

## New User Prompt
Convert the following AWS CDK Constructs to TerraConstructs.
```typescript
import { Construct } from 'constructs';
import { CfnTopic } from './sns.generated';
import { ITopic, TopicBase } from './topic-base';
import { IRole } from '../../aws-iam';
import { IKey } from '../../aws-kms';
import { ArnFormat, Lazy, Names, Stack, Token } from '../../core';

/**
 * Properties for a new SNS topic
 */
export interface TopicProps {
  /**
   * A developer-defined string that can be used to identify this SNS topic.
   *
   * The display name must be maximum 100 characters long, including hyphens (-),
   * underscores (_), spaces, and tabs.
   *
   * @default None
   */
  readonly displayName?: string;

  /**
   * A name for the topic.
   *
   * If you don't specify a name, AWS CloudFormation generates a unique
   * physical ID and uses that ID for the topic name. For more information,
   * see Name Type.
   *
   * @default Generated name
   */
  readonly topicName?: string;

  /**
   * A KMS Key, either managed by this CDK app, or imported.
   *
   * @default None
   */
  readonly masterKey?: IKey;

  /**
   * Enables content-based deduplication for FIFO topics.
   *
   * @default None
   */
  readonly contentBasedDeduplication?: boolean;

  /**
   * Set to true to create a FIFO topic.
   *
   * @default None
   */
  readonly fifo?: boolean;

  /**
   * The list of delivery status logging configurations for the topic.
   *
   * @see https://docs.aws.amazon.com/sns/latest/dg/sns-topic-attributes.html.
   *
   * @default None
   */
  readonly loggingConfigs?: LoggingConfig[];

  /**
   * The number of days Amazon SNS retains messages.
   *
   * It can only be set for FIFO topics.
   *
   * @see https://docs.aws.amazon.com/sns/latest/dg/fifo-message-archiving-replay.html
   *
   * @default - do not archive messages
   */
  readonly messageRetentionPeriodInDays?: number;

  /**
   * Adds a statement to enforce encryption of data in transit when publishing to the topic.
   *
   * @see https://docs.aws.amazon.com/sns/latest/dg/sns-security-best-practices.html#enforce-encryption-data-in-transit.
   *
   * @default false
   */
  readonly enforceSSL?: boolean;

  /**
   * The signature version corresponds to the hashing algorithm used while creating the signature of the notifications,
   * subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
   *
   * @see https://docs.aws.amazon.com/sns/latest/dg/sns-verify-signature-of-message.html.
   *
   * @default 1
   */
  readonly signatureVersion?: string;

  /**
   * Tracing mode of an Amazon SNS topic.
   *
   * @see https://docs.aws.amazon.com/sns/latest/dg/sns-active-tracing.html
   *
   * @default TracingConfig.PASS_THROUGH
   */
  readonly tracingConfig?: TracingConfig;
}

/**
 * A logging configuration for delivery status of messages sent from SNS topic to subscribed endpoints.
 *
 * @see https://docs.aws.amazon.com/sns/latest/dg/sns-topic-attributes.html.
 */
export interface LoggingConfig {
  /**
   * Indicates one of the supported protocols for the SNS topic.
   */
  readonly protocol: LoggingProtocol;

  /**
   * The IAM role to be used when logging failed message deliveries in Amazon CloudWatch.
   *
   * @default None
   */
  readonly failureFeedbackRole?: IRole;

  /**
   * The IAM role to be used when logging successful message deliveries in Amazon CloudWatch.
   *
   * @default None
   */
  readonly successFeedbackRole?: IRole;

  /**
   * The percentage of successful message deliveries to be logged in Amazon CloudWatch.
   *
   * Valid values are integer between 0-100
   *
   * @default None
   */
  readonly successFeedbackSampleRate?: number;
}

/**
 * The type of supported protocol for delivery status logging.
 */
export enum LoggingProtocol {
  /**
   * HTTP
   */
  HTTP = 'http/s',

  /**
   * Amazon Simple Queue Service
   */
  SQS = 'sqs',

  /**
   * AWS Lambda
   */
  LAMBDA = 'lambda',

  /**
   * Amazon Kinesis Data Firehose
   */
  FIREHOSE = 'firehose',

  /**
   * Platform application endpoint
   */
  APPLICATION = 'application',
}

/**
 * The tracing mode of an Amazon SNS topic
 */
export enum TracingConfig {
  /**
   * The mode that topic passes trace headers received from the Amazon SNS publisher to its subscription.
   */
  PASS_THROUGH = 'PassThrough',

  /**
   * The mode that Amazon SNS vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true.
   */
  ACTIVE = 'Active',
}

/**
 * Represents an SNS topic defined outside of this stack.
 */
export interface TopicAttributes {
  /**
   * The ARN of the SNS topic.
   */
  readonly topicArn: string;

  /**
   * Whether content-based deduplication is enabled.
   * Only applicable for FIFO topics.
   *
   * @default false
   */
  readonly contentBasedDeduplication?: boolean;
}

/**
 * A new SNS topic
 */
export class Topic extends TopicBase {

  /**
   * Import an existing SNS topic provided an ARN
   *
   * @param scope The parent creating construct
   * @param id The construct's name
   * @param topicArn topic ARN (i.e. arn:aws:sns:us-east-2:444455556666:MyTopic)
   */
  public static fromTopicArn(scope: Construct, id: string, topicArn: string): ITopic {
    return Topic.fromTopicAttributes(scope, id, { topicArn });
  };

  /**
   * Import an existing SNS topic provided a topic attributes
   *
   * @param scope The parent creating construct
   * @param id The construct's name
   * @param attrs the attributes of the topic to import
   */
  public static fromTopicAttributes(scope: Construct, id: string, attrs: TopicAttributes): ITopic {
    const topicName = Stack.of(scope).splitArn(attrs.topicArn, ArnFormat.NO_RESOURCE_NAME).resource;
    const fifo = topicName.endsWith('.fifo');

    if (attrs.contentBasedDeduplication && !fifo) {
      throw new Error('Cannot import topic; contentBasedDeduplication is only available for FIFO SNS topics.');
    }

    class Import extends TopicBase {
      public readonly topicArn = attrs.topicArn;
      public readonly topicName = topicName;
      public readonly fifo = fifo;
      public readonly contentBasedDeduplication = attrs.contentBasedDeduplication || false;
      protected autoCreatePolicy: boolean = false;
    }

    return new Import(scope, id, {
      environmentFromArn: attrs.topicArn,
    });
  }

  public readonly topicArn: string;
  public readonly topicName: string;
  public readonly contentBasedDeduplication: boolean;
  public readonly fifo: boolean;

  protected readonly autoCreatePolicy: boolean = true;

  private readonly loggingConfigs: LoggingConfig[] = [];

  constructor(scope: Construct, id: string, props: TopicProps = {}) {
    super(scope, id, {
      physicalName: props.topicName,
    });

    this.enforceSSL = props.enforceSSL;

    if (props.contentBasedDeduplication && !props.fifo) {
      throw new Error('Content based deduplication can only be enabled for FIFO SNS topics.');
    }
    if (props.messageRetentionPeriodInDays && !props.fifo) {
      throw new Error('`messageRetentionPeriodInDays` is only valid for FIFO SNS topics.');
    }
    if (
      props.messageRetentionPeriodInDays !== undefined
      && !Token.isUnresolved(props.messageRetentionPeriodInDays)
      && (!Number.isInteger(props.messageRetentionPeriodInDays) || props.messageRetentionPeriodInDays > 365 || props.messageRetentionPeriodInDays < 1)
    ) {
      throw new Error('`messageRetentionPeriodInDays` must be an integer between 1 and 365');
    }

    if (props.loggingConfigs) {
      props.loggingConfigs.forEach(c => this.addLoggingConfig(c));
    }

    let cfnTopicName: string;
    if (props.fifo && props.topicName && !props.topicName.endsWith('.fifo')) {
      cfnTopicName = this.physicalName + '.fifo';
    } else if (props.fifo && !props.topicName) {
      // Max length allowed by CloudFormation is 256, we subtract 5 to allow for ".fifo" suffix
      const prefixName = Names.uniqueResourceName(this, {
        maxLength: 256 - 5,
        separator: '-',
      });
      cfnTopicName = `${prefixName}.fifo`;
    } else {
      cfnTopicName = this.physicalName;
    }

    if (
      props.signatureVersion &&
      !Token.isUnresolved(props.signatureVersion) &&
      props.signatureVersion !== '1' &&
      props.signatureVersion !== '2'
    ) {
      throw new Error(`signatureVersion must be "1" or "2", received: "${props.signatureVersion}"`);
    }

    if (props.displayName && !Token.isUnresolved(props.displayName) && props.displayName.length > 100) {
      throw new Error(`displayName must be less than or equal to 100 characters, got ${props.displayName.length}`);
    }

    const resource = new CfnTopic(this, 'Resource', {
      archivePolicy: props.messageRetentionPeriodInDays ? {
        MessageRetentionPeriod: props.messageRetentionPeriodInDays,
      } : undefined,
      displayName: props.displayName,
      topicName: cfnTopicName,
      kmsMasterKeyId: props.masterKey && props.masterKey.keyArn,
      contentBasedDeduplication: props.contentBasedDeduplication,
      fifoTopic: props.fifo,
      signatureVersion: props.signatureVersion,
      deliveryStatusLogging: Lazy.any({ produce: () => this.renderLoggingConfigs() }, { omitEmptyArray: true }),
      tracingConfig: props.tracingConfig,
    });

    this.topicArn = this.getResourceArnAttribute(resource.ref, {
      service: 'sns',
      resource: this.physicalName,
    });
    this.topicName = this.getResourceNameAttribute(resource.attrTopicName);
    this.fifo = props.fifo || false;
    this.contentBasedDeduplication = props.contentBasedDeduplication || false;
  }

  private renderLoggingConfigs(): CfnTopic.LoggingConfigProperty[] {
    return this.loggingConfigs.map(renderLoggingConfig);

    function renderLoggingConfig(spec: LoggingConfig): CfnTopic.LoggingConfigProperty {
      if (spec.successFeedbackSampleRate !== undefined) {
        const rate = spec.successFeedbackSampleRate;
        if (!Number.isInteger(rate) || rate < 0 || rate > 100) {
          throw new Error('Success feedback sample rate must be an integer between 0 and 100');
        }
      }
      return {
        protocol: spec.protocol,
        failureFeedbackRoleArn: spec.failureFeedbackRole?.roleArn,
        successFeedbackRoleArn: spec.successFeedbackRole?.roleArn,
        successFeedbackSampleRate: spec.successFeedbackSampleRate?.toString(),
      };
    }
  }

  /**
   * Adds a delivery status logging configuration to the topic.
   */
  public addLoggingConfig(config: LoggingConfig) {
    this.loggingConfigs.push(config);
  }
}

```

## Reference Documents
**CDKTF Type Declarations:**:
Strictly adhere to the following type declarations for relevant CDKTF Resources:
```typescript
// sns-topic
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface SnsTopicConfig extends cdktf.TerraformMetaArguments {
    /** (Optional) IAM role for failure feedback */
    readonly applicationFailureFeedbackRoleArn?: string;
    /** (Optional) The IAM role permitted to receive success feedback for this topic */
    readonly applicationSuccessFeedbackRoleArn?: string;
    /** (Optional) Percentage of success to sample */
    readonly applicationSuccessFeedbackSampleRate?: number;
    /** (Optional) The message archive policy for FIFO topics. More details in the [AWS documentation](https://docs.aws.amazon.com/sns/latest/dg/message-archiving-and-replay-topic-owner.html). */
    readonly archivePolicy?: string;
    /** (Optional) Enables content-based deduplication for FIFO topics. For more information, see the [related documentation](https://docs.aws.amazon.com/sns/latest/dg/fifo-message-dedup.html) */
    readonly contentBasedDeduplication?: boolean | cdktf.IResolvable;
    /** (Optional) The SNS delivery policy. More details in the [AWS documentation](https://docs.aws.amazon.com/sns/latest/dg/DeliveryPolicies.html). */
    readonly deliveryPolicy?: string;
    /** (Optional) The display name for the topic */
    readonly displayName?: string;
    /** (Optional) Boolean indicating whether or not to create a FIFO (first-in-first-out) topic. FIFO topics can't deliver messages to customer managed endpoints, such as email addresses, mobile apps, SMS, or HTTP(S) endpoints. These endpoint types aren't guaranteed to preserve strict message ordering. Default is `false`. */
    readonly fifoTopic?: boolean | cdktf.IResolvable;
    /** (Optional) IAM role for failure feedback */
    readonly firehoseFailureFeedbackRoleArn?: string;
    /** (Optional) The IAM role permitted to receive success feedback for this topic */
    readonly firehoseSuccessFeedbackRoleArn?: string;
    /** (Optional) Percentage of success to sample */
    readonly firehoseSuccessFeedbackSampleRate?: number;
    /** (Optional) IAM role for failure feedback */
    readonly httpFailureFeedbackRoleArn?: string;
    /** (Optional) The IAM role permitted to receive success feedback for this topic */
    readonly httpSuccessFeedbackRoleArn?: string;
    /** (Optional) Percentage of success to sample */
    readonly httpSuccessFeedbackSampleRate?: number;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic#id SnsTopic#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /** (Optional) The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms) */
    readonly kmsMasterKeyId?: string;
    /** (Optional) IAM role for failure feedback */
    readonly lambdaFailureFeedbackRoleArn?: string;
    /** (Optional) The IAM role permitted to receive success feedback for this topic */
    readonly lambdaSuccessFeedbackRoleArn?: string;
    /** (Optional) Percentage of success to sample */
    readonly lambdaSuccessFeedbackSampleRate?: number;
    /** (Optional) The name of the topic. Topic names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters long. For a FIFO (first-in-first-out) topic, the name must end with the `.fifo` suffix. If omitted, Terraform will assign a random, unique name. Conflicts with `namePrefix` */
    readonly name?: string;
    /** (Optional) Creates a unique name beginning with the specified prefix. Conflicts with `name` */
    readonly namePrefix?: string;
    /** (Optional) The fully-formed AWS policy as JSON. For more information about building AWS IAM policy documents with Terraform, see the [AWS IAM Policy Document Guide](https://learn.hashicorp.com/terraform/aws/iam-policy). */
    readonly policy?: string;
    /** (Optional) If `SignatureVersion` should be [1 (SHA1) or 2 (SHA256)](https://docs.aws.amazon.com/sns/latest/dg/sns-verify-signature-of-message.html). The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS. */
    readonly signatureVersion?: number;
    /** (Optional) IAM role for failure feedback */
    readonly sqsFailureFeedbackRoleArn?: string;
    /** (Optional) The IAM role permitted to receive success feedback for this topic */
    readonly sqsSuccessFeedbackRoleArn?: string;
    /** (Optional) Percentage of success to sample */
    readonly sqsSuccessFeedbackSampleRate?: number;
    /** (Optional) Key-value map of resource tags. If configured with a provider [`defaultTags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level. */
    readonly tags?: {
        [key: string]: string;
    };
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic#tags_all SnsTopic#tags_all}
    */
    readonly tagsAll?: {
        [key: string]: string;
    };
    /** (Optional) Tracing mode of an Amazon SNS topic. Valid values: `"PassThrough"`, `"Active"`. */
    readonly tracingConfig?: string;
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic aws_sns_topic}
*/
export declare class SnsTopic extends cdktf.TerraformResource {
    static readonly tfResourceType = "aws_sns_topic";
    /**
    * Generates CDKTF code for importing a SnsTopic resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the SnsTopic to import
    * @param importFromId The id of the existing SnsTopic that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the SnsTopic to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic aws_sns_topic} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options SnsTopicConfig = {}
    */
    constructor(scope: Construct, id: string, config?: SnsTopicConfig);
    private _applicationFailureFeedbackRoleArn?;
    get applicationFailureFeedbackRoleArn(): string;
    set applicationFailureFeedbackRoleArn(value: string);
    resetApplicationFailureFeedbackRoleArn(): void;
    get applicationFailureFeedbackRoleArnInput(): string | undefined;
    private _applicationSuccessFeedbackRoleArn?;
    get applicationSuccessFeedbackRoleArn(): string;
    set applicationSuccessFeedbackRoleArn(value: string);
    resetApplicationSuccessFeedbackRoleArn(): void;
    get applicationSuccessFeedbackRoleArnInput(): string | undefined;
    private _applicationSuccessFeedbackSampleRate?;
    get applicationSuccessFeedbackSampleRate(): number;
    set applicationSuccessFeedbackSampleRate(value: number);
    resetApplicationSuccessFeedbackSampleRate(): void;
    get applicationSuccessFeedbackSampleRateInput(): number | undefined;
    private _archivePolicy?;
    get archivePolicy(): string;
    set archivePolicy(value: string);
    resetArchivePolicy(): void;
    get archivePolicyInput(): string | undefined;
    get arn(): string;
    get beginningArchiveTime(): string;
    private _contentBasedDeduplication?;
    get contentBasedDeduplication(): boolean | cdktf.IResolvable;
    set contentBasedDeduplication(value: boolean | cdktf.IResolvable);
    resetContentBasedDeduplication(): void;
    get contentBasedDeduplicationInput(): boolean | cdktf.IResolvable | undefined;
    private _deliveryPolicy?;
    get deliveryPolicy(): string;
    set deliveryPolicy(value: string);
    resetDeliveryPolicy(): void;
    get deliveryPolicyInput(): string | undefined;
    private _displayName?;
    get displayName(): string;
    set displayName(value: string);
    resetDisplayName(): void;
    get displayNameInput(): string | undefined;
    private _fifoTopic?;
    get fifoTopic(): boolean | cdktf.IResolvable;
    set fifoTopic(value: boolean | cdktf.IResolvable);
    resetFifoTopic(): void;
    get fifoTopicInput(): boolean | cdktf.IResolvable | undefined;
    private _firehoseFailureFeedbackRoleArn?;
    get firehoseFailureFeedbackRoleArn(): string;
    set firehoseFailureFeedbackRoleArn(value: string);
    resetFirehoseFailureFeedbackRoleArn(): void;
    get firehoseFailureFeedbackRoleArnInput(): string | undefined;
    private _firehoseSuccessFeedbackRoleArn?;
    get firehoseSuccessFeedbackRoleArn(): string;
    set firehoseSuccessFeedbackRoleArn(value: string);
    resetFirehoseSuccessFeedbackRoleArn(): void;
    get firehoseSuccessFeedbackRoleArnInput(): string | undefined;
    private _firehoseSuccessFeedbackSampleRate?;
    get firehoseSuccessFeedbackSampleRate(): number;
    set firehoseSuccessFeedbackSampleRate(value: number);
    resetFirehoseSuccessFeedbackSampleRate(): void;
    get firehoseSuccessFeedbackSampleRateInput(): number | undefined;
    private _httpFailureFeedbackRoleArn?;
    get httpFailureFeedbackRoleArn(): string;
    set httpFailureFeedbackRoleArn(value: string);
    resetHttpFailureFeedbackRoleArn(): void;
    get httpFailureFeedbackRoleArnInput(): string | undefined;
    private _httpSuccessFeedbackRoleArn?;
    get httpSuccessFeedbackRoleArn(): string;
    set httpSuccessFeedbackRoleArn(value: string);
    resetHttpSuccessFeedbackRoleArn(): void;
    get httpSuccessFeedbackRoleArnInput(): string | undefined;
    private _httpSuccessFeedbackSampleRate?;
    get httpSuccessFeedbackSampleRate(): number;
    set httpSuccessFeedbackSampleRate(value: number);
    resetHttpSuccessFeedbackSampleRate(): void;
    get httpSuccessFeedbackSampleRateInput(): number | undefined;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    private _kmsMasterKeyId?;
    get kmsMasterKeyId(): string;
    set kmsMasterKeyId(value: string);
    resetKmsMasterKeyId(): void;
    get kmsMasterKeyIdInput(): string | undefined;
    private _lambdaFailureFeedbackRoleArn?;
    get lambdaFailureFeedbackRoleArn(): string;
    set lambdaFailureFeedbackRoleArn(value: string);
    resetLambdaFailureFeedbackRoleArn(): void;
    get lambdaFailureFeedbackRoleArnInput(): string | undefined;
    private _lambdaSuccessFeedbackRoleArn?;
    get lambdaSuccessFeedbackRoleArn(): string;
    set lambdaSuccessFeedbackRoleArn(value: string);
    resetLambdaSuccessFeedbackRoleArn(): void;
    get lambdaSuccessFeedbackRoleArnInput(): string | undefined;
    private _lambdaSuccessFeedbackSampleRate?;
    get lambdaSuccessFeedbackSampleRate(): number;
    set lambdaSuccessFeedbackSampleRate(value: number);
    resetLambdaSuccessFeedbackSampleRate(): void;
    get lambdaSuccessFeedbackSampleRateInput(): number | undefined;
    private _name?;
    get name(): string;
    set name(value: string);
    resetName(): void;
    get nameInput(): string | undefined;
    private _namePrefix?;
    get namePrefix(): string;
    set namePrefix(value: string);
    resetNamePrefix(): void;
    get namePrefixInput(): string | undefined;
    get owner(): string;
    private _policy?;
    get policy(): string;
    set policy(value: string);
    resetPolicy(): void;
    get policyInput(): string | undefined;
    private _signatureVersion?;
    get signatureVersion(): number;
    set signatureVersion(value: number);
    resetSignatureVersion(): void;
    get signatureVersionInput(): number | undefined;
    private _sqsFailureFeedbackRoleArn?;
    get sqsFailureFeedbackRoleArn(): string;
    set sqsFailureFeedbackRoleArn(value: string);
    resetSqsFailureFeedbackRoleArn(): void;
    get sqsFailureFeedbackRoleArnInput(): string | undefined;
    private _sqsSuccessFeedbackRoleArn?;
    get sqsSuccessFeedbackRoleArn(): string;
    set sqsSuccessFeedbackRoleArn(value: string);
    resetSqsSuccessFeedbackRoleArn(): void;
    get sqsSuccessFeedbackRoleArnInput(): string | undefined;
    private _sqsSuccessFeedbackSampleRate?;
    get sqsSuccessFeedbackSampleRate(): number;
    set sqsSuccessFeedbackSampleRate(value: number);
    resetSqsSuccessFeedbackSampleRate(): void;
    get sqsSuccessFeedbackSampleRateInput(): number | undefined;
    private _tags?;
    get tags(): {
        [key: string]: string;
    };
    set tags(value: {
        [key: string]: string;
    });
    resetTags(): void;
    get tagsInput(): {
        [key: string]: string;
    } | undefined;
    private _tagsAll?;
    get tagsAll(): {
        [key: string]: string;
    };
    set tagsAll(value: {
        [key: string]: string;
    });
    resetTagsAll(): void;
    get tagsAllInput(): {
        [key: string]: string;
    } | undefined;
    private _tracingConfig?;
    get tracingConfig(): string;
    set tracingConfig(value: string);
    resetTracingConfig(): void;
    get tracingConfigInput(): string | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}


// sns-topic-data-protection-policy
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface SnsTopicDataProtectionPolicyConfig extends cdktf.TerraformMetaArguments {
    /** (Required) The ARN of the SNS topic */
    readonly arn: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_data_protection_policy#id SnsTopicDataProtectionPolicy#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /** (Required) The fully-formed AWS policy as JSON. For more information about building AWS IAM policy documents with Terraform, see the [AWS IAM Policy Document Guide](https://learn.hashicorp.com/terraform/aws/iam-policy). */
    readonly policy: string;
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_data_protection_policy aws_sns_topic_data_protection_policy}
*/
export declare class SnsTopicDataProtectionPolicy extends cdktf.TerraformResource {
    static readonly tfResourceType = "aws_sns_topic_data_protection_policy";
    /**
    * Generates CDKTF code for importing a SnsTopicDataProtectionPolicy resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the SnsTopicDataProtectionPolicy to import
    * @param importFromId The id of the existing SnsTopicDataProtectionPolicy that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_data_protection_policy#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the SnsTopicDataProtectionPolicy to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_data_protection_policy aws_sns_topic_data_protection_policy} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options SnsTopicDataProtectionPolicyConfig
    */
    constructor(scope: Construct, id: string, config: SnsTopicDataProtectionPolicyConfig);
    private _arn?;
    get arn(): string;
    set arn(value: string);
    get arnInput(): string | undefined;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    private _policy?;
    get policy(): string;
    set policy(value: string);
    get policyInput(): string | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}


// sns-topic-policy
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface SnsTopicPolicyConfig extends cdktf.TerraformMetaArguments {
    /** (Required) The ARN of the SNS topic */
    readonly arn: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_policy#id SnsTopicPolicy#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /** (Required) The fully-formed AWS policy as JSON. For more information about building AWS IAM policy documents with Terraform, see the [AWS IAM Policy Document Guide](https://learn.hashicorp.com/terraform/aws/iam-policy). */
    readonly policy: string;
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_policy aws_sns_topic_policy}
*/
export declare class SnsTopicPolicy extends cdktf.TerraformResource {
    static readonly tfResourceType = "aws_sns_topic_policy";
    /**
    * Generates CDKTF code for importing a SnsTopicPolicy resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the SnsTopicPolicy to import
    * @param importFromId The id of the existing SnsTopicPolicy that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_policy#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the SnsTopicPolicy to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_policy aws_sns_topic_policy} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options SnsTopicPolicyConfig
    */
    constructor(scope: Construct, id: string, config: SnsTopicPolicyConfig);
    private _arn?;
    get arn(): string;
    set arn(value: string);
    get arnInput(): string | undefined;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    get owner(): string;
    private _policy?;
    get policy(): string;
    set policy(value: string);
    get policyInput(): string | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}


// sns-topic-subscription
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface SnsTopicSubscriptionConfig extends cdktf.TerraformMetaArguments {
    /** (Optional) Integer indicating number of minutes to wait in retrying mode for fetching subscription arn before marking it as failure. Only applicable for http and https protocols. Default is `1`. */
    readonly confirmationTimeoutInMinutes?: number;
    /** (Optional) JSON String with the delivery policy (retries, backoff, etc.) that will be used in the subscription - this only applies to HTTP/S subscriptions. Refer to the [SNS docs](https://docs.aws.amazon.com/sns/latest/dg/DeliveryPolicies.html) for more details. */
    readonly deliveryPolicy?: string;
    /** (Required) Endpoint to send data to. The contents vary with the protocol. See details below. */
    readonly endpoint: string;
    /** (Optional) Whether the endpoint is capable of [auto confirming subscription](http://docs.aws.amazon.com/sns/latest/dg/SendMessageToHttp.html#SendMessageToHttp.prepare) (e.g., PagerDuty). Default is `false`. */
    readonly endpointAutoConfirms?: boolean | cdktf.IResolvable;
    /** (Optional) JSON String with the filter policy that will be used in the subscription to filter messages seen by the target resource. Refer to the [SNS docs](https://docs.aws.amazon.com/sns/latest/dg/message-filtering.html) for more details. */
    readonly filterPolicy?: string;
    /** (Optional) Whether the `filterPolicy` applies to `MessageAttributes` (default) or `MessageBody`. */
    readonly filterPolicyScope?: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_subscription#id SnsTopicSubscription#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /** (Required) Protocol to use. Valid values are: `sqs`, `sms`, `lambda`, `firehose`, and `application`. Protocols `email`, `email-json`, `http` and `https` are also valid but partially supported. See details below. */
    readonly protocol: string;
    /** (Optional) Whether to enable raw message delivery (the original message is directly passed, not wrapped in JSON with the original message in the message property). Default is `false`. */
    readonly rawMessageDelivery?: boolean | cdktf.IResolvable;
    /** (Optional) JSON String with the redrive policy that will be used in the subscription. Refer to the [SNS docs](https://docs.aws.amazon.com/sns/latest/dg/sns-dead-letter-queues.html#how-messages-moved-into-dead-letter-queue) for more details. */
    readonly redrivePolicy?: string;
    /** (Optional) JSON String with the archived message replay policy that will be used in the subscription. Refer to the [SNS docs](https://docs.aws.amazon.com/sns/latest/dg/message-archiving-and-replay-subscriber.html) for more details. ### Protocol support Supported values for `protocol` include: */
    readonly replayPolicy?: string;
    /** (Required if `protocol` is `firehose`) ARN of the IAM role to publish to Kinesis Data Firehose delivery stream. Refer to [SNS docs](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html). */
    readonly subscriptionRoleArn?: string;
    /** (Required) ARN of the SNS topic to subscribe to. The following arguments are optional: */
    readonly topicArn: string;
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_subscription aws_sns_topic_subscription}
*/
export declare class SnsTopicSubscription extends cdktf.TerraformResource {
    static readonly tfResourceType = "aws_sns_topic_subscription";
    /**
    * Generates CDKTF code for importing a SnsTopicSubscription resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the SnsTopicSubscription to import
    * @param importFromId The id of the existing SnsTopicSubscription that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_subscription#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the SnsTopicSubscription to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs/resources/sns_topic_subscription aws_sns_topic_subscription} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options SnsTopicSubscriptionConfig
    */
    constructor(scope: Construct, id: string, config: SnsTopicSubscriptionConfig);
    get arn(): string;
    private _confirmationTimeoutInMinutes?;
    get confirmationTimeoutInMinutes(): number;
    set confirmationTimeoutInMinutes(value: number);
    resetConfirmationTimeoutInMinutes(): void;
    get confirmationTimeoutInMinutesInput(): number | undefined;
    get confirmationWasAuthenticated(): cdktf.IResolvable;
    private _deliveryPolicy?;
    get deliveryPolicy(): string;
    set deliveryPolicy(value: string);
    resetDeliveryPolicy(): void;
    get deliveryPolicyInput(): string | undefined;
    private _endpoint?;
    get endpoint(): string;
    set endpoint(value: string);
    get endpointInput(): string | undefined;
    private _endpointAutoConfirms?;
    get endpointAutoConfirms(): boolean | cdktf.IResolvable;
    set endpointAutoConfirms(value: boolean | cdktf.IResolvable);
    resetEndpointAutoConfirms(): void;
    get endpointAutoConfirmsInput(): boolean | cdktf.IResolvable | undefined;
    private _filterPolicy?;
    get filterPolicy(): string;
    set filterPolicy(value: string);
    resetFilterPolicy(): void;
    get filterPolicyInput(): string | undefined;
    private _filterPolicyScope?;
    get filterPolicyScope(): string;
    set filterPolicyScope(value: string);
    resetFilterPolicyScope(): void;
    get filterPolicyScopeInput(): string | undefined;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    get ownerId(): string;
    get pendingConfirmation(): cdktf.IResolvable;
    private _protocol?;
    get protocol(): string;
    set protocol(value: string);
    get protocolInput(): string | undefined;
    private _rawMessageDelivery?;
    get rawMessageDelivery(): boolean | cdktf.IResolvable;
    set rawMessageDelivery(value: boolean | cdktf.IResolvable);
    resetRawMessageDelivery(): void;
    get rawMessageDeliveryInput(): boolean | cdktf.IResolvable | undefined;
    private _redrivePolicy?;
    get redrivePolicy(): string;
    set redrivePolicy(value: string);
    resetRedrivePolicy(): void;
    get redrivePolicyInput(): string | undefined;
    private _replayPolicy?;
    get replayPolicy(): string;
    set replayPolicy(value: string);
    resetReplayPolicy(): void;
    get replayPolicyInput(): string | undefined;
    private _subscriptionRoleArn?;
    get subscriptionRoleArn(): string;
    set subscriptionRoleArn(value: string);
    resetSubscriptionRoleArn(): void;
    get subscriptionRoleArnInput(): string | undefined;
    private _topicArn?;
    get topicArn(): string;
    set topicArn(value: string);
    get topicArnInput(): string | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}

```
**AWS CDK Type Declarations:**
Refer to the following Reference declarations used by the AWSCDK constructs:
```typescript
// sns.generated.d.ts
import * as cdk from "../../core";
import * as constructs from "constructs";
import * as cfn_parse from "../../core/lib/helpers-internal";
;
;
/**
 * The `AWS::SNS::Topic` resource creates a topic to which notifications can be published.
 *
 * > One account can create a maximum of 100,000 standard topics and 1,000 FIFO topics. For more information, see [Amazon SNS endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/sns.html) in the *AWS General Reference* .
 *
 * @cloudformationResource AWS::SNS::Topic
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html
 */
export declare class CfnTopic extends cdk.CfnResource implements cdk.IInspectable, cdk.ITaggable {
    /**
     * The CloudFormation resource type name for this resource class.
     */
    static readonly CFN_RESOURCE_TYPE_NAME: string;
    /**
     * Build a CfnTopic from CloudFormation properties
     *
     * A factory method that creates a new instance of this class from an object
     * containing the CloudFormation properties of this resource.
     * Used in the @aws-cdk/cloudformation-include module.
     *
     * @internal
     */
    static _fromCloudFormation(scope: constructs.Construct, id: string, resourceAttributes: any, options: cfn_parse.FromCloudFormationOptions): CfnTopic;
    /**
     * Returns the ARN of an Amazon SNS topic.
     *
     * @cloudformationAttribute TopicArn
     */
    readonly attrTopicArn: string;
    /**
     * Returns the name of an Amazon SNS topic.
     *
     * @cloudformationAttribute TopicName
     */
    readonly attrTopicName: string;
    /**
     * The `ArchivePolicy` determines the number of days Amazon SNS retains messages in FIFO topics.
     */
    archivePolicy?: any | cdk.IResolvable;
    /**
     * `ContentBasedDeduplication` enables deduplication of messages based on their content for FIFO topics.
     */
    contentBasedDeduplication?: boolean | cdk.IResolvable;
    /**
     * The body of the policy document you want to use for this topic.
     */
    dataProtectionPolicy?: any | cdk.IResolvable;
    /**
     * The `DeliveryStatusLogging` configuration enables you to log the delivery status of messages sent from your Amazon SNS topic to subscribed endpoints with the following supported delivery protocols:.
     */
    deliveryStatusLogging?: Array<cdk.IResolvable | CfnTopic.LoggingConfigProperty> | cdk.IResolvable;
    /**
     * The display name to use for an Amazon SNS topic with SMS subscriptions.
     */
    displayName?: string;
    /**
     * Specifies the throughput quota and deduplication behavior to apply for the FIFO topic.
     */
    fifoThroughputScope?: string;
    /**
     * Set to true to create a FIFO topic.
     */
    fifoTopic?: boolean | cdk.IResolvable;
    /**
     * The ID of an AWS managed customer master key (CMK) for Amazon SNS or a custom CMK.
     */
    kmsMasterKeyId?: string;
    /**
     * The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
     */
    signatureVersion?: string;
    /**
     * The Amazon SNS subscriptions (endpoints) for this topic.
     */
    subscription?: Array<cdk.IResolvable | CfnTopic.SubscriptionProperty> | cdk.IResolvable;
    /**
     * Tag Manager which manages the tags for this resource
     */
    readonly tags: cdk.TagManager;
    /**
     * The list of tags to add to a new topic.
     */
    tagsRaw?: Array<cdk.CfnTag>;
    /**
     * The name of the topic you want to create.
     */
    topicName?: string;
    /**
     * Tracing mode of an Amazon SNS topic.
     */
    tracingConfig?: string;
    /**
     * @param scope Scope in which this resource is defined
     * @param id Construct identifier for this resource (unique in its scope)
     * @param props Resource properties
     */
    constructor(scope: constructs.Construct, id: string, props?: CfnTopicProps);
    protected get cfnProperties(): Record<string, any>;
    /**
     * Examines the CloudFormation resource and discloses attributes
     *
     * @param inspector tree inspector to collect and process attributes
     */
    inspect(inspector: cdk.TreeInspector): void;
    protected renderProperties(props: Record<string, any>): Record<string, any>;
}
export declare namespace CfnTopic {
    /**
     * `Subscription` is an embedded property that describes the subscription endpoints of an Amazon SNS topic.
     *
     * > For full control over subscription behavior (for example, delivery policy, filtering, raw message delivery, and cross-region subscriptions), use the [AWS::SNS::Subscription](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-subscription.html) resource.
     *
     * @struct
     * @stability external
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic-subscription.html
     */
    interface SubscriptionProperty {
        /**
         * The endpoint that receives notifications from the Amazon SNS topic.
         *
         * The endpoint value depends on the protocol that you specify. For more information, see the `Endpoint` parameter of the `[Subscribe](https://docs.aws.amazon.com/sns/latest/api/API_Subscribe.html)` action in the *Amazon SNS API Reference* .
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic-subscription.html#cfn-sns-topic-subscription-endpoint
         */
        readonly endpoint: string;
        /**
         * The subscription's protocol.
         *
         * For more information, see the `Protocol` parameter of the `[Subscribe](https://docs.aws.amazon.com/sns/latest/api/API_Subscribe.html)` action in the *Amazon SNS API Reference* .
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic-subscription.html#cfn-sns-topic-subscription-protocol
         */
        readonly protocol: string;
    }
    /**
     * The `LoggingConfig` property type specifies the `Delivery` status logging configuration for an [`AWS::SNS::Topic`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html) .
     *
     * @struct
     * @stability external
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic-loggingconfig.html
     */
    interface LoggingConfigProperty {
        /**
         * The IAM role ARN to be used when logging failed message deliveries in Amazon CloudWatch.
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic-loggingconfig.html#cfn-sns-topic-loggingconfig-failurefeedbackrolearn
         */
        readonly failureFeedbackRoleArn?: string;
        /**
         * Indicates one of the supported protocols for the Amazon SNS topic.
         *
         * > At least one of the other three `LoggingConfig` properties is recommend along with `Protocol` .
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic-loggingconfig.html#cfn-sns-topic-loggingconfig-protocol
         */
        readonly protocol: string;
        /**
         * The IAM role ARN to be used when logging successful message deliveries in Amazon CloudWatch.
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic-loggingconfig.html#cfn-sns-topic-loggingconfig-successfeedbackrolearn
         */
        readonly successFeedbackRoleArn?: string;
        /**
         * The percentage of successful message deliveries to be logged in Amazon CloudWatch.
         *
         * Valid percentage values range from 0 to 100.
         *
         * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-topic-loggingconfig.html#cfn-sns-topic-loggingconfig-successfeedbacksamplerate
         */
        readonly successFeedbackSampleRate?: string;
    }
}
/**
 * Properties for defining a `CfnTopic`
 *
 * @struct
 * @stability external
 * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html
 */
export interface CfnTopicProps {
    /**
     * The `ArchivePolicy` determines the number of days Amazon SNS retains messages in FIFO topics.
     *
     * You can set a retention period ranging from 1 to 365 days. This property is only applicable to FIFO topics; attempting to use it with standard topics will result in a creation failure.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-archivepolicy
     */
    readonly archivePolicy?: any | cdk.IResolvable;
    /**
     * `ContentBasedDeduplication` enables deduplication of messages based on their content for FIFO topics.
     *
     * By default, this property is set to false. If you create a FIFO topic with `ContentBasedDeduplication` set to false, you must provide a `MessageDeduplicationId` for each `Publish` action. When set to true, Amazon SNS automatically generates a `MessageDeduplicationId` using a SHA-256 hash of the message body (excluding message attributes). You can optionally override this generated value by specifying a `MessageDeduplicationId` in the `Publish` action. Note that this property only applies to FIFO topics; using it with standard topics will cause the creation to fail.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-contentbaseddeduplication
     */
    readonly contentBasedDeduplication?: boolean | cdk.IResolvable;
    /**
     * The body of the policy document you want to use for this topic.
     *
     * You can only add one policy per topic.
     *
     * The policy must be in JSON string format.
     *
     * Length Constraints: Maximum length of 30,720.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-dataprotectionpolicy
     */
    readonly dataProtectionPolicy?: any | cdk.IResolvable;
    /**
     * The `DeliveryStatusLogging` configuration enables you to log the delivery status of messages sent from your Amazon SNS topic to subscribed endpoints with the following supported delivery protocols:.
     *
     * - HTTP
     * - Amazon Kinesis Data Firehose
     * - AWS Lambda
     * - Platform application endpoint
     * - Amazon Simple Queue Service
     *
     * Once configured, log entries are sent to Amazon CloudWatch Logs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-deliverystatuslogging
     */
    readonly deliveryStatusLogging?: Array<cdk.IResolvable | CfnTopic.LoggingConfigProperty> | cdk.IResolvable;
    /**
     * The display name to use for an Amazon SNS topic with SMS subscriptions.
     *
     * The display name must be maximum 100 characters long, including hyphens (-), underscores (_), spaces, and tabs.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-displayname
     */
    readonly displayName?: string;
    /**
     * Specifies the throughput quota and deduplication behavior to apply for the FIFO topic.
     *
     * Valid values are `Topic` or `MessageGroup` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-fifothroughputscope
     */
    readonly fifoThroughputScope?: string;
    /**
     * Set to true to create a FIFO topic.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-fifotopic
     */
    readonly fifoTopic?: boolean | cdk.IResolvable;
    /**
     * The ID of an AWS managed customer master key (CMK) for Amazon SNS or a custom CMK.
     *
     * For more information, see [Key terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms) . For more examples, see `[KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters)` in the *AWS Key Management Service API Reference* .
     *
     * This property applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html) .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-kmsmasterkeyid
     */
    readonly kmsMasterKeyId?: string;
    /**
     * The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
     *
     * By default, `SignatureVersion` is set to `1` .
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-signatureversion
     */
    readonly signatureVersion?: string;
    /**
     * The Amazon SNS subscriptions (endpoints) for this topic.
     *
     * > If you specify the `Subscription` property in the `AWS::SNS::Topic` resource and it creates an associated subscription resource, the associated subscription is not deleted when the `AWS::SNS::Topic` resource is deleted.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-subscription
     */
    readonly subscription?: Array<cdk.IResolvable | CfnTopic.SubscriptionProperty> | cdk.IResolvable;
    /**
     * The list of tags to add to a new topic.
     *
     * > To be able to tag a topic on creation, you must have the `sns:CreateTopic` and `sns:TagResource` permissions.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-tags
     */
    readonly tags?: Array<cdk.CfnTag>;
    /**
     * The name of the topic you want to create.
     *
     * Topic names must include only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters long. FIFO topic names must end with `.fifo` .
     *
     * If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the topic name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) .
     *
     * > If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-topicname
     */
    readonly topicName?: string;
    /**
     * Tracing mode of an Amazon SNS topic.
     *
     * By default `TracingConfig` is set to `PassThrough` , and the topic passes through the tracing header it receives from an Amazon SNS publisher to its subscriptions. If set to `Active` , Amazon SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sns-topic.html#cfn-sns-topic-tracingconfig
     */
    readonly tracingConfig?: string;
}
;
;
;
;

```
